<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sand with the Wind</title>
    <link>http://paliysha.site/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>once sunny ten times freezing</description>
    <pubDate>Thu, 24 May 2018 03:35:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Linux train route</title>
      <link>http://paliysha.site/2018/04/02/Linux-train-route/</link>
      <guid>http://paliysha.site/2018/04/02/Linux-train-route/</guid>
      <pubDate>Mon, 02 Apr 2018 03:23:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;来自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26859197&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Linux-学习路线&quot;&gt;&lt;a href=&quot;#Linux-学习路线&quot; clas
        
      
      </description>
      
      <content:encoded><![CDATA[<p>来自<a href="https://zhuanlan.zhihu.com/p/26859197" target="_blank" rel="noopener">这</a></p><h2 id="Linux-学习路线"><a href="#Linux-学习路线" class="headerlink" title="Linux 学习路线"></a>Linux 学习路线</h2><p>这是一幅路线图<img src="/2018/04/02/Linux-train-route/linux-route.jpg" alt="路线图"></p><p>不过需要说明的是，第五项驱动开发和第六项嵌入式系统开发是并列的，也就是说，学习完内核之后，你可以选择从事不同的领域，当然嵌入式开发有时会包含驱动开发。</p><p>还有就是嵌入式开发包括硬件，软件和系统开发，假如只做硬件的话，你没有必要按照上述路线进行，系统级开发的话，前面的是必备。</p><p><strong>熟悉 Linux 系统，基本命令</strong></p><p>安装 Linux 系统，学会基本操作，熟悉文件系统，shell 脚本以及常用命令。</p><p><strong>了解程序开发过程</strong></p><p>搭建开发环境，了解 Linux 上程序开发过程。</p><p>学会使用文本编辑工具 Vim，编译工具 gcc, as, 连接工具 ld, 调试工具 gdb， make 工具，会写 makefile。</p><p>用 C 语言实现并编译自己的测试程序。</p><p><strong>尝试系统编程</strong></p><p>试着在 Linux 上用 C 语言进行系统编程，</p><p>其中需要调用 Linux 系统库函数 （API）。</p><p>例如，实现一个需要进行网络通信、操作文件的多线程/进程程序。</p><p>以此深入了解 Linux 系统运行机制。</p><p><strong>学习内核</strong></p><p>上面学的差不多了，感兴趣的同学可以接着学习 Linux 内核。</p><p>Linux 内核模块如下图</p><p><img src="/2018/04/02/Linux-train-route/linux-fwork.jpg" alt="内核模块"></p><p>这一部分内容比较深，能把它学透的基本就是大牛了，写个 OS 就不在话下了。</p><p><strong>驱动开发</strong></p><p>从这里开始，就不是必须的了。</p><p>有兴趣的朋友可以深入学习。</p><p>但是学习驱动开发无疑要把前面的都要学好。</p><p><strong>嵌入式系统开发</strong></p><p>学好 Linux 是嵌入式系统开发的基础。</p><p>嵌入式开发包括很多方向，有硬件、软件，以及系统级别。</p><p>硬件要学单片机，ARM、MIPS，DSP 等各种 MCU，Verilog， RTL， 具体就不多说了，跟 Linux 关系不太大。</p><p>软件的话，需要了解交叉编译，以及嵌入式环境下 C 语言的特殊用法，例如 volatile、 位操作、寄存器操作、大小端、程序跳转等。</p><p>系统级，要了解 Linux 内核裁剪、移植、编译、调试，还有 Bootloader 、设备驱动等。</p>]]></content:encoded>
      
      <comments>http://paliysha.site/2018/04/02/Linux-train-route/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript Basic Introduction</title>
      <link>http://paliysha.site/2018/03/29/JavaScript-Basic-Introduction/</link>
      <guid>http://paliysha.site/2018/03/29/JavaScript-Basic-Introduction/</guid>
      <pubDate>Thu, 29 Mar 2018 06:56:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;JavaScript历史&quot;&gt;&lt;a href=&quot;#JavaScript历史&quot; class=&quot;headerlink&quot; title=&quot;JavaScript历史&quot;&gt;&lt;/a&gt;JavaScript历史&lt;/h4&gt;&lt;p&gt;在上个世纪的1995年，当时的网景公司正凭借其Navigat
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="JavaScript历史"><a href="#JavaScript历史" class="headerlink" title="JavaScript历史"></a>JavaScript历史</h4><p>在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。</p><p>由于网景公司希望能在静态HTML页面上添加一些动态效果，于是Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。</p><p>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系</p><h4 id="JavaScript的作用"><a href="#JavaScript的作用" class="headerlink" title="JavaScript的作用"></a>JavaScript的作用</h4><ul><li>操作网页元素： 静态和动态效果</li><li>传递数据：与后台交互数据</li><li>响应用户输入：处理各种输入事件</li></ul><h4 id="JavaScript的内容范围"><a href="#JavaScript的内容范围" class="headerlink" title="JavaScript的内容范围"></a>JavaScript的内容范围</h4><p>归结起来就两个东西 <strong>对象</strong> 和 <strong>事件</strong></p><h4 id="JavaScript组成部分"><a href="#JavaScript组成部分" class="headerlink" title="JavaScript组成部分"></a>JavaScript组成部分</h4><ul><li><p>JavaScript核心语法</p><blockquote><p>变量，常量，运算符，控制语句，函数，对象</p></blockquote></li><li><p>BOM ：浏览器对象模型，其实就是JavaScript里面有操作浏览器的知识</p></li><li><p>DOM：文档对象模型 ，HTML DOM 定义了所有 HTML 元素的<em>对象</em>和<em>属性</em>，以及访问它们的<em>方法</em>。 换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。</p></li></ul><p>注： DOM包含三层意思(HTML文档被浏览器解析后就是一棵DOM树)：</p><ol><li>DOM是一个操作HTML的API接口</li><li>DOM是一个HTML结构模型</li><li>DOM代指该HTML模型中的对象</li></ol><p>总结： 简单地说，BOM和DOM一样，只不过DOM操作的是HTML中的元素，BOM是浏览器的API、操作的是浏览器（即控制浏览器的行为）</p><h3 id="JavaScript引入方式"><a href="#JavaScript引入方式" class="headerlink" title="JavaScript引入方式"></a>JavaScript引入方式</h3><ul><li>外部引用：把另外一个js文件引入到这个html文件中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;  </span><br><span class="line">        引入外部js  </span><br><span class="line">        &lt;button id=&quot;button&quot;&gt;实验&lt;/button&gt;  </span><br><span class="line">        &lt;script src=&quot;demo.js&quot;&gt;     </span><br><span class="line">        &lt;/script&gt;  </span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注：外部js嵌入另一个外部js，document.write(““)</p><ul><li>嵌入方式：可以写在head中，也可以写在body末尾</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;  </span><br><span class="line">       直接在HTML中嵌入</span><br><span class="line">       &lt;button id=&quot;button&quot;&gt;实验&lt;/button&gt;  </span><br><span class="line">       &lt;script&gt;  </span><br><span class="line">           button.onclick=function()  </span><br><span class="line">           &#123;  </span><br><span class="line">               alert(&quot;引入方法一：直接嵌入script标签&quot;);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &lt;/script&gt;  </span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><ul><li>事件监听处调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;  </span><br><span class="line">js的引入方式实验  </span><br><span class="line">&lt;button id=&quot;button&quot; onclick=&quot;javascript:alert(&apos;js引入的方式3：事件定义&apos;)&quot;&gt;实验&lt;/button&gt;  </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><ul><li>域名或者是重定向</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;form action=&quot;javascript:&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>JS的注释：</strong></p><p>JS单行注释是用//，多行注释以 / <em>开始，以</em> / 结尾。</p><p>结束*/</p><p><strong>JS的输出：</strong></p><p>alert() 弹出对话框；</p><p>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中；</p><p><strong>JS的变量：</strong></p><p>var是JS中的通用类型变量，可以随便存储其它类型的值，可以直接使用，不用定义。</p><p>var name;name 为变量名，可以有字母，数字 ，下划线组成，但不能用数字 开头，不区分 大小写</p><p><strong>数字类型：</strong></p><p>int :整数型</p><p>string;字符型</p><p>double;双精度</p><p>flout;单精度</p><p>boolen;布尔型</p><p>attr=array()数姐</p><p>类型的转换：</p><p>将其他类型转换成整数型：parseint()</p><p>将其他 类型转换成小数型：parsefloat()</p><p>判断是否是一个合法的数字类型：isNaN()</p><p><strong>运算符：</strong></p><p>数学运算符有：+, - ,* ,/,%,++,–</p><p>关系运算符有：== ！= =&gt; =&lt;</p><p>逻辑运算符有：&amp;&amp; （并） ||（与） ！（非）</p><p>给定 x=6 以及 y=3，下表解释了逻辑运算符：</p><p>(x &lt; 10 &amp;&amp; y &gt; 1) 为 true//两个条件同时满足为 true，有一个不满足为 false</p><p>(x==5 || y==5) 为 false//两个条件有一个满足为 true，都不满足为 false</p><p>!(x==y) 为 true//如果不满足为 true，满足为 false</p><p>运算符 = 用于赋值。</p><p>运算符 + 用于加值。</p><h3 id="第三方js库"><a href="#第三方js库" class="headerlink" title="第三方js库"></a>第三方js库</h3><p><strong>jQuery</strong> “Write Less, Do More“</p><ul><li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li><li>简洁的操作DOM的方法：写<code>$(&#39;#test&#39;)</code>肯定比<code>document.getElementById(&#39;test&#39;)</code>来得简洁；</li><li>轻松实现动画、修改CSS等各种操作。</li></ul><p><strong>underscore</strong> 函数式编程<br>Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法. 所以:<br>使用统一开源库的函数来实现map()、filter()等等操作</p><p><strong>node.js</strong> 异步IO缺陷的应用<br>在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js</p><p><strong>React</strong> 用于构建用户界面的 JavaScript 库</p><p>参考文章：</p><p><a href="http://docs.cocos.com/creator/manual/zh/scripting/javascript-primer.html" target="_blank" rel="noopener">JavaScript 快速入门</a></p>]]></content:encoded>
      
      <comments>http://paliysha.site/2018/03/29/JavaScript-Basic-Introduction/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Custom View Components</title>
      <link>http://paliysha.site/2018/03/28/Custom-View-Components/</link>
      <guid>http://paliysha.site/2018/03/28/Custom-View-Components/</guid>
      <pubDate>Wed, 28 Mar 2018 03:28:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;自定义View为什么这么难？他到底难在哪里，尤其是设计到动效和事件交互的时候。&lt;/p&gt;
&lt;p&gt;那么，我们需要不断实践练习和补充完整的知识才行！这一篇权当入门。&lt;/p&gt;
&lt;h4 id=&quot;一-View的构造函数和常见函数&quot;&gt;&lt;a href=&quot;#一-View的构造函数和常见函数&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>自定义View为什么这么难？他到底难在哪里，尤其是设计到动效和事件交互的时候。</p><p>那么，我们需要不断实践练习和补充完整的知识才行！这一篇权当入门。</p><h4 id="一-View的构造函数和常见函数"><a href="#一-View的构造函数和常见函数" class="headerlink" title="一. View的构造函数和常见函数"></a>一. View的构造函数和常见函数</h4><p>Constructor to use when creating a view from code.</p><ul><li>View(Context context)</li></ul><p>Constructor that is called when inflating a view from XML.</p><ul><li>View(Context context, @Nullable AttributeSet attrs)</li><li>View(Context context, @Nullable AttributeSet attrs, int defStyleAttr)</li><li>View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)</li></ul><p>后面三个方法的逻辑都是同一个，最后系统都会调用最后一个函数（因为其通过this(…)指向了4参函数）.<br>所以：</p><ol><li>如果不对二参数构造方法使用this(x,x,R.attr.CustomizeStyleAttr)进行传参，系统会将第三个参数设为0;</li><li>如果不对三参数构造方法使用this(x,x,x,R.styl.CustomizeStyleRes)进行传参,系统会将第四个参数设为0。</li></ol><p>四参构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">View(x,x,x,x)&#123;</span><br><span class="line">    <span class="keyword">this</span>(context);<span class="comment">//首先也需要调用代码形式的构造方法</span></span><br><span class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDebugViewAttributes) &#123;</span><br><span class="line">            saveAttributeData(attrs, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后解析处TypeArray里面的参数值</span></span><br><span class="line">    <span class="comment">//其他...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结: 解析属性的优先级： xml &gt; style &gt; defStyleAttr &gt; defStyleRes &gt; theme。<br>也就是主题theme作为当前Activity通用系的属性可以单独设置某个样式属性item，但是它只有在defStyleAttr和defStyleRes都为0的情况下才会使用自己的样式属性值。<br><strong>所以我们不用管defStyleAttr和defStyleRes让他采用系统属性（在主题theme更改系统属性值不推荐，除非是为了统一风格，针对单独的某个自定义View做更改会影响其他视图），可以采用自定义属性做到更改想要的效果而不影响其他的View（这个时候需要自己在调用super(…)之后将设定的属性值解析出来然后通过调用属性set函数设置到对应的代码属性之上）。</strong></p><ul><li>onFinishInflate():加载完XML组件后回调</li><li>onSizeChanged():组件大小改变时回调</li><li>onMeasure():回调该方法来进行测量（在该方法中实现对wrap_content支持的代码）</li><li>onLayout():回调该方法来显示位置。在自定义ViewGroup中会用到，他调用的是子View的layout函数。onLayout一般是循环取出子View，然后经过计算得出各个子View位置的坐标值，然后用chid.layout(l,t,r,b)函数设置子View位置。</li><li>onTouchEvent():监听到触摸事件回调，也是实现交互非常重要的回调方法</li><li>onDraw():回调该方法对我们的控件进行绘制</li></ul><p>注： onFinishInflite()或onAttachToWindow(): 可以得到子View对象</p><h4 id="二-3种自定义View"><a href="#二-3种自定义View" class="headerlink" title="二. 3种自定义View"></a>二. 3种自定义View</h4><ul><li><p><strong>扩展式：</strong></p><p>扩展式自定义View继承自Android原生特定的View如：TextView，ImageView等等。我们通过重写onDrow()等回调方法对其进行<strong>扩展</strong>！使其实现我们想要的<strong>功能或样式</strong>！</p><p><strong>注：</strong>该方法实现的自定义View控件<strong>不</strong>需要自己支持wrap_content和padding。</p></li><li><p><strong>组合式：</strong></p><p>组合式自定义View继承自ViewGrop的子View如：LinearLayout、RelativieLayout等。当某种效果看起来像几种<strong>View组合</strong>在一起的时候，都可以使用这种方式实现。</p><p><strong>注：</strong>该方式实现自定义View<strong>不</strong>需要自己处理ViewGroup的测量和布局这两个过程。</p></li><li><p><strong>完全自定义：</strong><br>完全自定义View继承自View（android中所有控件的基类），通常实现一些不方便布局的组合方式来达到的，需要静态或动态地显示一些<strong>不规则</strong>的控件或图形！</p><p><strong>注：**</strong>该方法实现的自定义View控件<strong>需要</strong>自己支持wrap_content和padding。**</p></li></ul><h4 id="三-绘制流程-函数调用链"><a href="#三-绘制流程-函数调用链" class="headerlink" title="三. 绘制流程-函数调用链"></a>三. 绘制流程-函数调用链</h4><p><img src="/2018/03/28/Custom-View-Components/cst_view_drawing_flowsheet.jpg" alt="绘制流程函数调用图"></p><h4 id="三-View生命周期"><a href="#三-View生命周期" class="headerlink" title="三. View生命周期"></a>三. View生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 可见性改变 or Activity.onCreate()</span><br><span class="line">op0=&gt;operation: 实例化View-调用View构造方法</span><br><span class="line">op1=&gt;operation: View.onFinishInflate()</span><br><span class="line">op2=&gt;operation: View.onAttachedToWindow()</span><br><span class="line">op3=&gt;operation: View.onMeasure()</span><br><span class="line">op4=&gt;operation: View.onSizeChanged()</span><br><span class="line">op5=&gt;operation: onLayout()</span><br><span class="line">op6=&gt;operation: onDraw()</span><br><span class="line">cond=&gt;condition: Activity.onDestroy()</span><br><span class="line">op=&gt;operation: View.onDetachedFromWindow()</span><br><span class="line">sub1=&gt;subroutine: 子流程1</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op0-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;cond</span><br><span class="line">cond(yes)-&gt;op-&gt;e</span><br><span class="line">cond(no)-&gt;e</span><br></pre></td></tr></table></figure><h2 id="四-自定义步骤"><a href="#四-自定义步骤" class="headerlink" title="四. 自定义步骤"></a>四. 自定义步骤</h2><ol><li>自定义View的属性</li><li>在构造方法中获取自定义属性</li><li>重写onMesure(可根据情况省略这一步)</li><li>重写onDraw</li></ol><p>注：</p><ul><li>对于具有滑动效果的自定义View，还要做相关的滑动处理</li><li>如果遇到滑动冲突还需要解决相应的滑动冲突</li></ul><p>第3步：(通常可以不重写该方法)</p><ul><li>不重写：View这个类交给系统默认的处理</li><li>重写：如果View类的默认处理不满足我们的要求，我们就重写onMeasure函数</li></ul><p><code>wrap_content</code>或者是<code>match_parent</code>设置并没有指定真正的大小，可是我们绘制到屏幕上的View必须是要有具体的宽高，假如我们需要自顶一个正方形View这个时候必须对</p><p>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){ … }</p><p>进行重写。</p><p>1和2就省略了，从第三步开始。</p><h4 id="五-视需要重写onMeasure（设计宽高和测量模式）"><a href="#五-视需要重写onMeasure（设计宽高和测量模式）" class="headerlink" title="五. 视需要重写onMeasure（设计宽高和测量模式）"></a>五. 视需要重写onMeasure（设计宽高和测量模式）</h4><p>widthMeasureSpec, heightMeasureSpec都是int型，一个int有4字节存储空间。</p><p>所以，对这4字节即32bit划分可以表示多个信息：最高位2bit用于区分测量模式(2的2次方=4，完全可以涵盖<code>UNSPECIFIED</code>，<code>EXACTLY</code>，<code>AT_MOST</code>这3种测量模式)，后面30bit存放宽或高的大小信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br></pre></td></tr></table></figure><p>注：其实以上两个方法内部就进行bit位隔开取的计算了(移位<code>&lt;&lt;</code>和且<code>&amp;</code>操作)</p><p>分析：此时获取的宽高的大小并不是最终绘制出来的大小，其大小来自父亲view的参考值。</p><table><thead><tr><th>测量模式</th><th>表示意思</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td>父容器没有对当前View有任何限制，当前View可以任意取尺寸</td></tr><tr><td>EXACTLY</td><td>当前的尺寸就是当前View应该取的尺寸（固定值和 match_parent）</td></tr><tr><td>AT_MOST</td><td>当前尺寸是当前View能取的最大尺寸（ wrap_content）</td></tr></tbody></table><p><strong>对wrap_content的支持</strong></p><p>在onMeasure()方法中实现对wrap_content的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize= MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpectMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="comment">//这里就是对wrap_content的支持</span></span><br><span class="line">    <span class="keyword">if</span>(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpectMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        <span class="comment">//这里设定的根据你自己自定义View的情况而定</span></span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(widthSpecMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>,heightSpecSize);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (heightSpectMode==MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasuredDimension(widthSpecSize,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： 不要调用super.onMeasure( widthMeasureSpec, heightMeasureSpec);</p><p><strong>对padding的支持</strong></p><p>在onDraw()方法中实现对padding的支持，其实就是在绘制控件时考虑到padding就好了。如果不自己实现那么你对该自定义View设置padding将是无效的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    <span class="comment">//这里是对画一个圆形的View的padding支持</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = getPaddingLeft();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingRight = getPaddingRight();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingBottom=getPaddingBottom();</span><br><span class="line">    <span class="keyword">int</span> width = getWidth()-paddingLeft-paddingRight;</span><br><span class="line">    <span class="keyword">int</span> height = getHeight()-paddingBottom-paddingTop;</span><br><span class="line">    <span class="keyword">int</span> radius = Math.min(width,height)/<span class="number">2</span>;</span><br><span class="line">    canvas.drawCircle(paddingLeft+width/<span class="number">2</span>,paddingTop+height/<span class="number">2</span>,radius,mPaint_while);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六-重写onDraw（实现效果）"><a href="#六-重写onDraw（实现效果）" class="headerlink" title="六. 重写onDraw（实现效果）"></a>六. 重写onDraw（实现效果）</h4><p>Canvas对象：画板</p><p>Canvas常用操作速查表：</p><table><thead><tr><th>操作分类</th><th>相关API</th><th>备注</th></tr></thead><tbody><tr><td>绘制颜色</td><td>drawColor, drawRGB, drawARGB</td><td>使用单一颜色填充整个画布</td></tr><tr><td>绘制基本形状</td><td>drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td><td>依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧</td></tr><tr><td>绘制图片</td><td>drawBitmap, drawPicture</td><td>绘制位图和图片)</td></tr><tr><td>绘制文本</td><td>drawText, drawPosText, drawTextOnPath</td><td>依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td></tr><tr><td>绘制路径</td><td>drawPath</td><td>绘制路径，绘制贝塞尔曲线时也需要用到该函数</td></tr><tr><td>顶点操作</td><td>drawVertices, drawBitmapMesh</td><td>通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用</td></tr><tr><td>画布剪裁</td><td>clipPath, clipRect</td><td>设置画布的显示区域</td></tr><tr><td>画布快照</td><td>save, restore, saveLayerXxx, restoreToCount, getSaveCount</td><td>依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 会滚到指定状态、 获取保存次数</td></tr><tr><td>画布变换</td><td>translate, scale, rotate, skew</td><td>依次为 位移、缩放、 旋转、错切</td></tr><tr><td>Matrix(矩阵)</td><td>getMatrix, setMatrix, concat</td><td>实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。</td></tr><tr><td>基础方法</td><td>getDensity, getWidth, getHeight，getDrawFilter，isHardwareAccelerated(API 11)，getMaximumBitmapWidth，getMaximumBitmapHeight，getDensity，quickReject，isOpaque，setBitmap，setDrawFilter</td><td>其他函数</td></tr></tbody></table><p>Path常用操作速查表：</p><table><thead><tr><th>作用</th><th>相关API</th><th>备注</th></tr></thead><tbody><tr><td>移动起点</td><td>moveTo</td><td>移动下一次操作的起点位置</td></tr><tr><td>设置终点</td><td>setLastPoint</td><td>重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同</td></tr><tr><td>连接直线</td><td>lineTo</td><td>添加上一个点到当前点之间的直线到Path</td></tr><tr><td>闭合路径</td><td>close</td><td>连接第一个点连接到最后一个点，形成一个闭合区域</td></tr><tr><td>添加内容</td><td>addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo</td><td>添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)</td></tr><tr><td>是否为空</td><td>isEmpty</td><td>判断Path是否为空</td></tr><tr><td>是否为矩形</td><td>isRect</td><td>判断path是否是一个矩形</td></tr><tr><td>替换路径</td><td>set</td><td>用新的路径替换到当前路径所有内容</td></tr><tr><td>偏移路径</td><td>offset</td><td>对当前路径之前的操作进行偏移(不会影响之后的操作)</td></tr><tr><td>贝塞尔曲线</td><td>quadTo, cubicTo</td><td>分别为二次和三次贝塞尔曲线的方法</td></tr><tr><td>rXxx方法</td><td>rMoveTo, rLineTo, rQuadTo, rCubicTo</td><td><strong>不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</strong></td></tr><tr><td>填充模式</td><td>setFillType, getFillType, isInverseFillType, toggleInverseFillType</td><td>设置,获取,判断和切换填充模式</td></tr><tr><td>提示方法</td><td>incReserve</td><td>提示Path还有多少个点等待加入<strong>(这个方法貌似会让Path优化存储结构)</strong></td></tr><tr><td>布尔操作(API19)</td><td>op</td><td>对两个Path进行布尔运算(即取交集、并集等操作)</td></tr><tr><td>计算边界</td><td>computeBounds</td><td>计算Path的边界</td></tr><tr><td>重置路径</td><td>reset, rewind</td><td>清除Path中的内容 <strong>reset不保留内部数据结构，但会保留FillType.</strong> <strong>rewind会保留内部的数据结构，但不保留FillType</strong></td></tr><tr><td>矩阵操作</td><td>transform</td><td>矩阵变换</td></tr></tbody></table><p>Matrix常用操作速查表：</p><table><thead><tr><th>方法类别</th><th>相关API</th><th>备注</th></tr></thead><tbody><tr><td>基本方法</td><td>equals hashCode toString toShortString</td><td>比较、 获取哈希值、 转换为字符串</td></tr><tr><td>数值操作</td><td>set reset setValues getValues</td><td>设置、 重置、 设置数值、 获取数值</td></tr><tr><td>数值计算</td><td>mapPoints mapRadius mapRect mapVectors</td><td>计算变换后的数值</td></tr><tr><td>设置(set)</td><td>setConcat setRotate setScale setSkew setTranslate</td><td>设置变换</td></tr><tr><td>前乘(pre)</td><td>preConcat preRotate preScale preSkew preTranslate</td><td>前乘变换</td></tr><tr><td>后乘(post)</td><td>postConcat postRotate postScale postSkew postTranslate</td><td>后乘变换</td></tr><tr><td>特殊方法</td><td>setPolyToPoly setRectToRect rectStaysRect setSinCos</td><td>一些特殊操作</td></tr><tr><td>矩阵相关</td><td>invert isAffine(API21) isIdentity</td><td>求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵 …</td></tr></tbody></table><p>贝塞尔曲线常用操作速查表：</p><table><thead><tr><th>贝塞尔曲线</th><th>对应的方法</th><th>演示动画</th></tr></thead><tbody><tr><td>一阶曲线(线性曲线)</td><td>lineTo</td><td><a href="https://user-gold-cdn.xitu.io/2017/8/23/05750d8554a308b440e7ebbfea88c525?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2017/8/23/05750d8554a308b440e7ebbfea88c525?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></a></td></tr><tr><td>二阶曲线</td><td>quadTo</td><td><a href="https://user-gold-cdn.xitu.io/2017/8/23/2a39d3cb8a36dbe8ddb3d068adffc00b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2017/8/23/2a39d3cb8a36dbe8ddb3d068adffc00b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></a></td></tr><tr><td>三阶曲线</td><td>cubicTo</td><td><a href="https://user-gold-cdn.xitu.io/2017/8/23/bd9b5ba0ef55d80f6ed3cc395ca95112?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2017/8/23/bd9b5ba0ef55d80f6ed3cc395ca95112?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></a></td></tr><tr><td>四阶曲线</td><td>无</td><td><a href="https://user-gold-cdn.xitu.io/2017/8/23/bddf32dad9399c44dd232328ce56a2a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2017/8/23/bddf32dad9399c44dd232328ce56a2a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></a></td></tr></tbody></table><hr><p>自定义View的延伸：<strong>自定义ViewGroup</strong></p><p>设计思路:</p><blockquote><p>1.首先，我们得知道各个子View的大小吧，只有先知道子View的大小，我们才知道当前的ViewGroup该设置为多大去容纳它们。</p><p>2.根据子View的大小，以及我们的ViewGroup要实现的功能，决定出ViewGroup的大小</p><p>3.ViewGroup和子View的大小算出来了之后，接下来就是去摆放了吧，具体怎么去摆放呢？这得根据你定制的需求去摆放了，比如，你想让子View按照垂直顺序一个挨着一个放，或者是按照先后顺序一个叠一个去放，这是你自己决定的。</p><p>4.已经知道怎么去摆放还不行啊，决定了怎么摆放就是相当于把已有的空间”分割”成大大小小的空间，每个空间对应一个子View，我们接下来就是把子View对号入座了，把它们放进它们该放的地方去。</p></blockquote><p>步骤：(实现ViewGroup垂直摆放child view)</p><ol><li>重写onMeasure，实现测量子View大小以及设定ViewGroup的大小</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="comment">//将所有的子View进行测量，这会触发每个子View的onMeasure函数</span></span><br><span class="line">        <span class="comment">//注意要与measureChild区分，measureChild是对单个view进行测量</span></span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;<span class="comment">//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间</span></span><br><span class="line">            setMeasuredDimension(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果宽高都是包裹内容</span></span><br><span class="line">            <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                <span class="comment">//我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</span></span><br><span class="line">                <span class="keyword">int</span> height = getTotleHeight();</span><br><span class="line">                <span class="keyword">int</span> width = getMaxChildWidth();</span><br><span class="line">                setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;<span class="comment">//如果只有高度是包裹内容</span></span><br><span class="line">                <span class="comment">//宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</span></span><br><span class="line">                setMeasuredDimension(widthSize, getTotleHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;<span class="comment">//如果只有宽度是包裹内容</span></span><br><span class="line">                <span class="comment">//宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</span></span><br><span class="line">                setMeasuredDimension(getMaxChildWidth(), heightSize);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 获取子View中宽度最大的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxChildWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (childView.getMeasuredWidth() &gt; maxWidth)</span><br><span class="line">                maxWidth = childView.getMeasuredWidth();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 将所有子View的高度相加</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotleHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            height += childView.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>摆放child View</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="comment">//记录当前的高度位置</span></span><br><span class="line">        <span class="keyword">int</span> curHeight = t;</span><br><span class="line">        <span class="comment">//将子View逐个摆放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="comment">//摆放子View，参数分别是子View矩形区域的左、上、右、下边</span></span><br><span class="line">            child.layout(l, curHeight, l + width, curHeight + height);</span><br><span class="line">            curHeight += height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参看文章：</p><p><a href="https://developer.android.com/guide/topics/ui/custom-components" target="_blank" rel="noopener">Developers</a></p><p><a href="https://www.jianshu.com/p/c84693096e41" target="_blank" rel="noopener">自定义View，有这一篇就够了</a></p><p><a href="https://juejin.im/post/599d2b2e518825242238d4f6" target="_blank" rel="noopener">自定义view总结</a></p><p><a href="https://www.jianshu.com/p/bcae9ec222e6" target="_blank" rel="noopener">自定义View之总结</a></p><p><a href="https://blog.csdn.net/cjm2484836553/article/details/71024436" target="_blank" rel="noopener">自定义View（三）—自定义View整个流程的梳理与总结 - 李诗雨</a></p><p>引申：</p><p><a href="http://blog.csdn.net/lmj623565791/article/details/24300125" target="_blank" rel="noopener">Android 自定义View (二) 进阶 - Hongyang)</a></p><p><a href="https://medium.com/@romandanylyk96/android-draw-a-custom-view-ef79fe2ff54b" target="_blank" rel="noopener">Android: draw a custom view - Roman Danylyk (Medium)</a></p><p><a href="http://hencoder.com/ui-1-1/" target="_blank" rel="noopener">HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础</a></p><p><a href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B01%5DCustomViewProcess.md" target="_blank" rel="noopener">自定义View分类与流程</a></p><p><a href="http://www.gcssloop.com/#blog" target="_blank" rel="noopener">GcsSloop</a></p><p><a href="https://www.jianshu.com/p/08be3c08c576" target="_blank" rel="noopener">深度解析View构造函数中的参数defStyleAttr</a></p><p><a href="https://blog.csdn.net/lue2009/article/details/45692009" target="_blank" rel="noopener">View的生命周期方法和Activity生命周期方法关系</a></p>]]></content:encoded>
      
      <comments>http://paliysha.site/2018/03/28/Custom-View-Components/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Interview Resources</title>
      <link>http://paliysha.site/2018/03/27/Interview-Resources/</link>
      <guid>http://paliysha.site/2018/03/27/Interview-Resources/</guid>
      <pubDate>Tue, 27 Mar 2018 04:09:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/leetcode-hust/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;louyutong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>资料：</p><ul><li><a href="https://github.com/leetcode-hust/" target="_blank" rel="noopener">louyutong</a></li></ul>]]></content:encoded>
      
      <comments>http://paliysha.site/2018/03/27/Interview-Resources/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java VM</title>
      <link>http://paliysha.site/2018/03/27/Java-VM/</link>
      <guid>http://paliysha.site/2018/03/27/Java-VM/</guid>
      <pubDate>Tue, 27 Mar 2018 03:55:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;注： 转自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25713880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java JVM 运行机制及基本原理 - 韦庆明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将知识用文字记录下来，供以后温故知
        
      
      </description>
      
      <content:encoded><![CDATA[<p>注： 转自<a href="https://zhuanlan.zhihu.com/p/25713880" target="_blank" rel="noopener">Java JVM 运行机制及基本原理 - 韦庆明</a></p><p>将知识用文字记录下来，供以后温故知新。</p><h2 id="JVM的基础概念"><a href="#JVM的基础概念" class="headerlink" title="JVM的基础概念"></a><strong>JVM的基础概念</strong></h2><p>JVM的中文名称叫Java虚拟机，它是由软件技术模拟出计算机运行的一个虚拟的计算机。</p><p>JVM也充当着一个翻译官的角色，我们编写出的Java程序，是不能够被操作系统所直接识别的，这时候JVM的作用就体现出来了，它负责把我们的程序翻译给系统“听”，告诉它我们的程序需要做什么操作。</p><p>我们都知道Java的程序需要经过编译后，产生.Class文件，JVM才能识别并运行它，JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因。</p><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h2><p>JVM在Java程序开始执行的时候，它才运行，程序结束的时它就停止。</p><p>一个Java程序会开启一个JVM进程，如果一台机器上运行三个程序，那么就会有三个运行中的JVM进程。</p><p>JVM中的线程分为两种：守护线程和普通线程</p><p>守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。</p><p>普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。</p><p>权限足够的话，可以调用exit()方法终止程序。</p><h2 id="JVM的结构体系"><a href="#JVM的结构体系" class="headerlink" title="JVM的结构体系"></a><strong>JVM的结构体系</strong></h2><p><img src="/2018/03/27/Java-VM/jvm_st.jpg" alt="img"></p><h2 id="JVM的启动过程"><a href="#JVM的启动过程" class="headerlink" title="JVM的启动过程"></a><strong>JVM的启动过程</strong></h2><p><strong>1、JVM的装入环境和配置</strong></p><p>在学习这个之前，我们需要了解一件事情，就是JDK和JRE的区别。</p><p>JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境，JDK中包含了JRE。</p><p>JRE是Java的运行环境，是面向所有Java程序的使用者，包括开发者。</p><p><strong>JRE = 运行环境 = JVM</strong>。</p><p>如果安装了JDK，会发现电脑中有两套JRE，一套位于/Java/jre…/下，一套位于/Java/jdk…/jre下。那么问题来了，一台机器上有两套以上JRE，谁来决定运行那一套呢？这个任务就落到java.exe身上，java.exe的任务就是找到合适的JRE来运行java程序。</p><p>java.exe按照以下的顺序来选择JRE：</p><p>1、自己目录下有没有JRE</p><p>2、父目录下有没有JRE</p><p>3、查询注册表： HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\”当前JRE版本号”\JavaHome</p><p>这几步的主要核心是为了找到JVM的绝对路径。</p><p><strong>jvm.cfg</strong>的路径为：JRE路径\lib\”CPU架构”\jvm.fig</p><p><strong>jvm.cfg</strong>的内容大致如下：</p><p>-client KNOWN</p><p>-server KNOWN</p><p>-hotspot ALIASED_TO -client</p><p>-classic WARN</p><p>-native ERROR</p><p>-green ERROR</p><p>KNOWN 表示存在 、IGNORE 表示不存在 、ALIASED_TO 表示给别的JVM去一个别名</p><p>WARN 表示不存在时找一个替代 、ERROR 表示不存在抛出异常</p><p>2、装载JVM</p><p>通过第一步找到JVM的路径后，Java.exe通过LoadJavaVM来装入JVM文件。<br>LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。<br><strong>3、初始化JVM，获得本地调用接口</strong></p><p>调用InvocationFunction -&gt; CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例。<br><strong>4、运行Java程序</strong></p><p>JVM运行Java程序的方式有两种：jar包 与 Class<br><strong>运行jar 的时候</strong>，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用JarFileJNIEnv类中getManifest()，从其返回的Manifest对象中取getAttrebutes(“Main-Class”)的值，即jar 包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。<br><strong>运行Class的时候</strong>，main函数直接调用Java.c中的LoadClass方法装载该类。</p><h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a><strong>Class文件</strong></h2><p>Class文件由Java编译器生成，我们创建的.Java文件在经过编译器后，会变成.Class的文件，这样才能被JVM所识别并运行。</p><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a><strong>类加载子系统</strong></h2><p>类加载子系统也可以称之为类加载器，JVM默认提供三个类加载器：</p><p><strong>1、BootStrap ClassLoader</strong> ：称之为启动类加载器，是最顶层的类加载器，<strong>负责加载JDK中的核心类库，如 rt.jar、resources.jar、charsets.jar等</strong>。</p><p><strong>2、Extension ClassLoader</strong>：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p><p><strong>3、App ClassLoader</strong>：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。</p><p>除了Java默认提供的三个ClassLoader（加载器）之外，我们还可以根据自身需要自定义ClassLoader，自定义ClassLoader必须继承java.lang.ClassLoader 类。<strong>除了BootStrap ClassLoader 之外</strong>的另外两个默认加载器都是继承自java.lang.ClassLoader 。BootStrap ClassLoader 不是一个普通的Java类，它底层由C++编写，已嵌入到了JVM的内核当中，当JVM启动后，BootStrap ClassLoader 也随之启动，负责加载完核心类库后，并构造Extension ClassLoader 和App ClassLoader 类加载器。</p><p>类加载器子系统不仅仅负责定位并加载类文件，它还严格按照以下步骤做了很多事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、加载：寻找并导入Class文件的二进制信息</span><br><span class="line">2、连接：进行验证、准备和解析</span><br><span class="line">     1）验证：确保导入类型的正确性</span><br><span class="line">     2）准备：为类型分配内存并初始化为默认值</span><br><span class="line">     3）解析：将字符引用解析为直接引用</span><br><span class="line">3、初始化：调用Java代码，初始化类变量为指定初始值</span><br></pre></td></tr></table></figure><p>详细请参考另一篇文章：<a href="https://zhuanlan.zhihu.com/p/25228545" target="_blank" rel="noopener">Java类加载机制 - 知乎专栏</a></p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a><strong>方法区（Method Area）</strong></h2><p>在JVM中，<strong>类型信息</strong>和<strong>类静态变量</strong>都保存在方法区中，类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。</p><p>需要注意的一点是，<strong>常量池也存放于方法区中</strong>。</p><p>程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。</p><p>在程序运行时，方法区的大小是可以改变的，程序在运行时可以扩展。</p><p>方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下，详情可以参考另一篇文章：<a href="https://zhuanlan.zhihu.com/p/25539690" target="_blank" rel="noopener">Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏</a></p><p><strong>类型信息包括什么？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、类型的全名（The fully qualified name of the type）</span><br><span class="line"></span><br><span class="line">2、类型的父类型全名（除非没有父类型，或者父类型是java.lang.Object）（The fully qualified name of the typeís direct superclass）</span><br><span class="line"></span><br><span class="line">3、该类型是一个类还是接口（class or an interface）（Whether or not the type is a class ）</span><br><span class="line"></span><br><span class="line">4、类型的修饰符（public，private，protected，static，final，volatile，transient等）（The typeís modifiers）</span><br><span class="line"></span><br><span class="line">5、所有父接口全名的列表（An ordered list of the fully qualified names of any direct superinterfaces）</span><br><span class="line"></span><br><span class="line">6、类型的字段信息（Field information）</span><br><span class="line"></span><br><span class="line">7、类型的方法信息（Method information）</span><br><span class="line"></span><br><span class="line">8、所有静态类变量（非常量）信息（All class (static) variables declared in the type, except constants）</span><br><span class="line"></span><br><span class="line">9、一个指向类加载器的引用（A reference to class ClassLoader）</span><br><span class="line"></span><br><span class="line">10、一个指向Class类的引用（A reference to class Class）</span><br><span class="line"></span><br><span class="line">11、基本类型的常量池（The constant pool for the type）</span><br></pre></td></tr></table></figure><p><strong>方法列表（Method Tables）</strong></p><p>为了更高效的访问所有保存在方法区中的数据，在方法区中，除了保存上边的这些类型信息之外，还有一个为了加快存取速度而设计的数据结构：方法列表。每一个被加载的非抽象类，Java虚拟机都会为他们产生一个方法列表，这个列表中保存了这个类可能调用的所有实例方法的引用，保存那些父类中调用的方法。</p><h2 id="Java堆（JVM堆、Heap）"><a href="#Java堆（JVM堆、Heap）" class="headerlink" title="Java堆（JVM堆、Heap）"></a><strong>Java堆（JVM堆</strong>、<strong>Heap）</strong></h2><p>当Java<strong>创建一个类的实例对象或者数组时，都在堆中为新的对象分配内存</strong>。</p><p>虚拟机中只有一个堆，程序中所有的线程都共享它。</p><p>堆占用的内存空间是最多的。</p><p>堆的存取类型为管道类型，先进先出。</p><p>在程序运行中，可以动态的分配堆的内存大小。</p><p>堆的内存资源回收是交给JVM GC进行管理的，详情请参考：<a href="https://zhuanlan.zhihu.com/p/25539690" target="_blank" rel="noopener">Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏</a></p><h2 id="Java栈（JVM栈、Stack）"><a href="#Java栈（JVM栈、Stack）" class="headerlink" title="Java栈（JVM栈、Stack）"></a><strong>Java栈（JVM栈、Stack）</strong></h2><p>在Java栈中<strong>只保存基础数据类型</strong>（<strong>参考：</strong><a href="https://zhuanlan.zhihu.com/p/25439066" target="_blank" rel="noopener">Java 基本数据类型 - 四类八种 - 知乎专栏</a>）和自定义对象的<strong>引用</strong>，<strong>注意只是对象的引用而不是对象本身哦</strong>，对象是保存在堆区中的。</p><p><strong>拓展知识：像String、Integer、Byte、Short、Long、Character、Boolean这六个属于包装类型，它们是存放于堆中的。</strong></p><p>栈的存取类型为类似于水杯，先进后出。</p><p>栈内的数据在超出其作用域后，会被自动释放掉，<strong>它不由JVM GC管理</strong>。</p><p>每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。</p><p>每个线程都会建立一个操作栈，每个栈又包含了若干个栈帧，每个栈帧对应着每个方法的每次调用，每个栈帧包含了三部分：</p><p>局部变量区（方法内基本类型变量、变量对象指针）</p><p>操作数栈区（存放方法执行过程中产生的中间结果）</p><p>运行环境区（动态连接、正确的方法返回相关信息、异常捕捉）</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h2><p>本地方法栈的功能和JVM栈非常类似，用于存储本地方法的局部变量表，本地方法的操作数栈等信息。</p><p>栈的存取类型为类似于水杯，先进后出。</p><p>栈内的数据在超出其作用域后，会被自动释放掉，<strong>它不由JVM GC管理。</strong></p><p>每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。</p><p>本地方法栈是在程序调用或JVM调用<strong>本地方法接口（Native）</strong>时候启用。</p><p>本地方法都不是使用Java语言编写的，比如使用C语言编写的本地方法，本地方法也不由JVM去运行，所以本地方法的运行不受JVM管理。</p><p>HotSpot VM将本地方法栈和JVM栈合并了。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h2><p>在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以<strong>每条线程都会有一个独立的程序计数器</strong>。</p><p>程序计数器仅占很小的一块内存空间。</p><p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p><p>程序计数器这个内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。</p><h2 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a><strong>JVM执行引擎</strong></h2><p>Java虚拟机相当于一台虚拟的“物理机”，这两种机器都有代码执行能力，其区别主要是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。而JVM的执行引擎是自己实现的，因此程序员可以自行制定指令集和执行引擎的结构体系，因此能够执行那些不被硬件直接支持的指令集格式。</p><p>在JVM规范中制定了虚拟机字节码执行引擎的概念模型，这个模型称之为JVM执行引擎的统一外观。JVM实现中，可能会有两种的执行方式：解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码）。有些虚拟机只采用一种执行方式，有些则可能同时采用两种，甚至有可能包含几个不同级别的编译器执行引擎。</p><p><strong>输入的是字节码文件、处理过程是等效字节码解析过程、输出的是执行结果</strong>。在这三点上每个JVM执行引擎都是一致的。</p><h2 id="本地方法接口（JNI）"><a href="#本地方法接口（JNI）" class="headerlink" title="本地方法接口（JNI）"></a><strong>本地方法接口（JNI）</strong></h2><p>JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C和C++）。</p><p><strong>JNI的适用场景</strong></p><p>当我们有一些旧的库，已经使用C语言编写好了，如果要移植到Java上来，非常浪费时间，而JNI可以支持Java程序与C语言编写的库进行交互，这样就不必要进行移植了。或者是与硬件、操作系统进行交互、提高程序的性能等，都可以使用JNI。需要注意的一点是需要保证本地代码能工作在任何Java虚拟机环境。</p><p><strong>JNI的副作用</strong></p><p>一旦使用JNI，Java程序将丢失了Java平台的两个优点：</p><p>1、程序不再跨平台，要想跨平台，必须在不同的系统环境下程序编译配置本地语言部分。</p><p>2、程序不再是绝对安全的，本地代码的使用不当可能会导致整个程序崩溃。一个通用规则是，调用本地方法应该集中在少数的几个类当中，这样就降低了Java和其他语言之间的耦合。</p><h2 id="JVM-GC（垃圾回收机制）"><a href="#JVM-GC（垃圾回收机制）" class="headerlink" title="JVM GC（垃圾回收机制）"></a><strong>JVM GC（垃圾回收机制）</strong></h2><p>详情请参考我的另外一篇文章：<a href="https://zhuanlan.zhihu.com/p/25539690" target="_blank" rel="noopener">Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏</a></p><h2 id="JVM-常量池"><a href="#JVM-常量池" class="headerlink" title="JVM 常量池"></a><strong>JVM 常量池</strong></h2><p>JVM常量池也称之为运行时常量池，<strong>它是方法区（Method Area）的一部分</strong>。<strong>用于存放编译期间生成的各种字面量和符号引用。运行时常量池不要求一定只有在编译器产生的才能进入，运行期间也可以将新的常量放入池中，这种特性被开发人员利用比较多的就是String.intern()方法。</strong></p><p>由<strong>“**</strong>用于存放编译期间生成的各种字面量和符号引用”<strong>这句话可见，</strong>常量池中存储的是对象的引用而不是对象的本身**。</p><p><strong>常量池的好处</strong></p><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，它也实现了对象的共享。</p><p>例如字符串常量池：在编译阶段就把所有字符串文字放到一个常量池中。</p><p>1、节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。</p><p>2、节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，==判断引用是否相等，也就可以判断实际值是否相等。</p><p><strong>双等号（==）的含义</strong></p><p>基本数据类型之间使用双等号，比较的是数值。</p><p>复合数据类型（类）之间使用双等号，比较的是对象的引用地址是否相等。</p><p><strong>八种基本类型的包装类和常量池</strong></p><p>Byte、Short、Integer、Long、Character、Boolean、String这7种包装类都各自实现了自己的常量池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//例子：</span><br><span class="line">Integer i1 = 20;</span><br><span class="line">Integer i2 = 20;</span><br><span class="line">System.out.println(i1=i2);//输出TRUE</span><br></pre></td></tr></table></figure><p>Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。<strong>当对这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//IntegerCache.low = -128</span><br><span class="line">//IntegerCache.high = 127</span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//例子</span><br><span class="line">Integer i1 = 200;</span><br><span class="line">Integer i2 = 200;</span><br><span class="line">System.out.println(i1==i2);//返回FALSE</span><br></pre></td></tr></table></figure><p><strong>Float 和Double 没有实现常量池</strong>。</p><p><strong>String包装类与常量池</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa&quot;;</span><br></pre></td></tr></table></figure><p>当以上代码运行时，JVM会到字符串常量池查找 “aaa” 这个字面量对象是否存在？</p><p><strong>存在</strong>：则返回该对象的引用给变量 <strong>str1</strong> 。</p><p><strong>不存在</strong>：则在堆中创建一个相应的对象，将创建的对象的引用存放到常量池中，同时将引用返回给变量 <strong>str1</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa&quot;;</span><br><span class="line">String str2 = &quot;aaa&quot;;</span><br><span class="line">System.out.println(str1 == str2);//返回TRUE</span><br></pre></td></tr></table></figure><p>因为变量<strong>str1</strong> 和<strong>str2</strong> 都指向同一个对象，所以返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str3 = new String(&quot;aaa&quot;);</span><br><span class="line">System.out.println(str1 == str3);//返回FALSE</span><br></pre></td></tr></table></figure><p>当我们使用了<strong>new</strong>来构造字符串对象的时候，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建。因为两个指向的是不同的对象，所以返回FALSE 。</p><p><strong>String.intern()方法</strong></p><p>对于使用了new 创建的字符串对象，如果想要将这个对象引用到字符串常量池，可以使用intern() 方法。</p><p>调用intern() 方法后，检查字符串常量池中是否有这个对象的引用，并做如下操作：</p><p>存在：直接返回对象引用给变量。</p><p>不存在：将这个对象引用加入到常量池，再返回对象引用给变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String interns = str3.intern();</span><br><span class="line">System.out.println(interns == str1);//返回TRUE</span><br></pre></td></tr></table></figure><p>假定常量池中都没有以上字面量的对象，以下创建了多少个对象呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str4 = &quot;abc&quot;+&quot;efg&quot;;</span><br><span class="line">String str5 = &quot;abcefg&quot;;</span><br><span class="line">System.out.println(str4 == str5);//返回TRUE</span><br></pre></td></tr></table></figure><p>答案是三个。第一个：”abc” ，第一个：”efg”，第三个：”abc”+”efg”（”abcefg”）</p><p>String str5 = “abcefg”; 这句代码并没有创建对象，它从常量池中找到了”abcefg” 的引用，所有str4 == str5 返回TRUE，因为它们都指向一个相同的对象。</p><p><strong>什么情况下会将字符串对象引用自动加入字符串常量池？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//只有在这两种情况下会将对象引用自动加入到常量池</span><br><span class="line">String str1 = &quot;aaa&quot;;</span><br><span class="line">String str2 = &quot;aa&quot;+&quot;a&quot;;</span><br><span class="line"></span><br><span class="line">//其他方式下都不会将对象引用自动加入到常量池，如下：</span><br><span class="line">String str3 = new String(&quot;aaa&quot;);</span><br><span class="line">String str4 = New StringBuilder(&quot;aa&quot;).append(&quot;a&quot;).toString();</span><br><span class="line">StringBuilder sb = New StringBuilder();</span><br><span class="line">sb.append(&quot;aa&quot;);</span><br><span class="line">sb.append(&quot;a&quot;);</span><br><span class="line">String str5 = sb.toString();</span><br></pre></td></tr></table></figure><p>好了，JVM的基本原理就写到这里，以后更深入的了解后会再来补充。</p>]]></content:encoded>
      
      <comments>http://paliysha.site/2018/03/27/Java-VM/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
