<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux train route]]></title>
    <url>%2F2018%2F04%2F02%2FLinux-train-route%2F</url>
    <content type="text"><![CDATA[来自这 Linux 学习路线这是一幅路线图 不过需要说明的是，第五项驱动开发和第六项嵌入式系统开发是并列的，也就是说，学习完内核之后，你可以选择从事不同的领域，当然嵌入式开发有时会包含驱动开发。 还有就是嵌入式开发包括硬件，软件和系统开发，假如只做硬件的话，你没有必要按照上述路线进行，系统级开发的话，前面的是必备。 熟悉 Linux 系统，基本命令 安装 Linux 系统，学会基本操作，熟悉文件系统，shell 脚本以及常用命令。 了解程序开发过程 搭建开发环境，了解 Linux 上程序开发过程。 学会使用文本编辑工具 Vim，编译工具 gcc, as, 连接工具 ld, 调试工具 gdb， make 工具，会写 makefile。 用 C 语言实现并编译自己的测试程序。 尝试系统编程 试着在 Linux 上用 C 语言进行系统编程， 其中需要调用 Linux 系统库函数 （API）。 例如，实现一个需要进行网络通信、操作文件的多线程/进程程序。 以此深入了解 Linux 系统运行机制。 学习内核 上面学的差不多了，感兴趣的同学可以接着学习 Linux 内核。 Linux 内核模块如下图 这一部分内容比较深，能把它学透的基本就是大牛了，写个 OS 就不在话下了。 驱动开发 从这里开始，就不是必须的了。 有兴趣的朋友可以深入学习。 但是学习驱动开发无疑要把前面的都要学好。 嵌入式系统开发 学好 Linux 是嵌入式系统开发的基础。 嵌入式开发包括很多方向，有硬件、软件，以及系统级别。 硬件要学单片机，ARM、MIPS，DSP 等各种 MCU，Verilog， RTL， 具体就不多说了，跟 Linux 关系不太大。 软件的话，需要了解交叉编译，以及嵌入式环境下 C 语言的特殊用法，例如 volatile、 位操作、寄存器操作、大小端、程序跳转等。 系统级，要了解 Linux 内核裁剪、移植、编译、调试，还有 Bootloader 、设备驱动等。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Basic Introduction]]></title>
    <url>%2F2018%2F03%2F29%2FJavaScript-Basic-Introduction%2F</url>
    <content type="text"><![CDATA[JavaScript历史在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。 为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系 JavaScript的作用 操作网页元素： 静态和动态效果 传递数据：与后台交互数据 响应用户输入：处理各种输入事件 JavaScript的内容范围归结起来就两个东西 对象 和 事件 JavaScript组成部分 JavaScript核心语法 变量，常量，运算符，控制语句，函数，对象 BOM ：浏览器对象模型，其实就是JavaScript里面有操作浏览器的知识 DOM：文档对象模型 ，HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。 换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。 注： DOM包含三层意思(HTML文档被浏览器解析后就是一棵DOM树)： DOM是一个操作HTML的API接口 DOM是一个HTML结构模型 DOM代指该HTML模型中的对象 总结： 简单地说，BOM和DOM一样，只不过DOM操作的是HTML中的元素，BOM是浏览器的API、操作的是浏览器（即控制浏览器的行为） JavaScript引入方式 外部引用：把另外一个js文件引入到这个html文件中 123456&lt;body&gt; 引入外部js &lt;button id=&quot;button&quot;&gt;实验&lt;/button&gt; &lt;script src=&quot;demo.js&quot;&gt; &lt;/script&gt; &lt;/body&gt; 注：外部js嵌入另一个外部js，document.write(““) 嵌入方式：可以写在head中，也可以写在body末尾 1234567891011&lt;body&gt; 直接在HTML中嵌入 &lt;button id=&quot;button&quot;&gt;实验&lt;/button&gt; &lt;script&gt; button.onclick=function() &#123; alert(&quot;引入方法一：直接嵌入script标签&quot;); &#125; &lt;/script&gt; &lt;/body&gt; 事件监听处调用 1234&lt;body&gt; js的引入方式实验 &lt;button id=&quot;button&quot; onclick=&quot;javascript:alert(&apos;js引入的方式3：事件定义&apos;)&quot;&gt;实验&lt;/button&gt; &lt;/body&gt; 域名或者是重定向 123&lt;a href=&quot;javascript:&quot;&gt;&lt;/a&gt;&lt;form action=&quot;javascript:&quot;&gt;&lt;/form&gt; 基本语法JS的注释： JS单行注释是用//，多行注释以 / 开始，以 / 结尾。 结束*/ JS的输出： alert() 弹出对话框； 使用 document.write() 方法将内容写到 HTML 文档中； JS的变量： var是JS中的通用类型变量，可以随便存储其它类型的值，可以直接使用，不用定义。 var name;name 为变量名，可以有字母，数字 ，下划线组成，但不能用数字 开头，不区分 大小写 数字类型： int :整数型 string;字符型 double;双精度 flout;单精度 boolen;布尔型 attr=array()数姐 类型的转换： 将其他类型转换成整数型：parseint() 将其他 类型转换成小数型：parsefloat() 判断是否是一个合法的数字类型：isNaN() 运算符： 数学运算符有：+, - ,* ,/,%,++,– 关系运算符有：== ！= =&gt; =&lt; 逻辑运算符有：&amp;&amp; （并） ||（与） ！（非） 给定 x=6 以及 y=3，下表解释了逻辑运算符： (x &lt; 10 &amp;&amp; y &gt; 1) 为 true//两个条件同时满足为 true，有一个不满足为 false (x==5 || y==5) 为 false//两个条件有一个满足为 true，都不满足为 false !(x==y) 为 true//如果不满足为 true，满足为 false 运算符 = 用于赋值。 运算符 + 用于加值。 第三方js库jQuery “Write Less, Do More“ 消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码； 简洁的操作DOM的方法：写$(&#39;#test&#39;)肯定比document.getElementById(&#39;test&#39;)来得简洁； 轻松实现动画、修改CSS等各种操作。 underscore 函数式编程Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法. 所以:使用统一开源库的函数来实现map()、filter()等等操作 node.js 异步IO缺陷的应用在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js React 用于构建用户界面的 JavaScript 库 参考文章： JavaScript 快速入门]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Custom View Components]]></title>
    <url>%2F2018%2F03%2F28%2FCustom-View-Components%2F</url>
    <content type="text"><![CDATA[自定义View为什么这么难？他到底难在哪里，尤其是设计到动效和事件交互的时候。 那么，我们需要不断实践练习和补充完整的知识才行！这一篇权当入门。 一. View的构造函数和常见函数Constructor to use when creating a view from code. View(Context context) Constructor that is called when inflating a view from XML. View(Context context, @Nullable AttributeSet attrs) View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) 后面三个方法的逻辑都是同一个，最后系统都会调用最后一个函数（因为其通过this(…)指向了4参函数）.所以： 如果不对二参数构造方法使用this(x,x,R.attr.CustomizeStyleAttr)进行传参，系统会将第三个参数设为0; 如果不对三参数构造方法使用this(x,x,x,R.styl.CustomizeStyleRes)进行传参,系统会将第四个参数设为0。 四参构造如下： 1234567891011View(x,x,x,x)&#123; this(context);//首先也需要调用代码形式的构造方法 final TypedArray a = context.obtainStyledAttributes( attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes); if (mDebugViewAttributes) &#123; saveAttributeData(attrs, a); &#125; //然后解析处TypeArray里面的参数值 //其他...&#125; 总结: 解析属性的优先级： xml &gt; style &gt; defStyleAttr &gt; defStyleRes &gt; theme。也就是主题theme作为当前Activity通用系的属性可以单独设置某个样式属性item，但是它只有在defStyleAttr和defStyleRes都为0的情况下才会使用自己的样式属性值。所以我们不用管defStyleAttr和defStyleRes让他采用系统属性（在主题theme更改系统属性值不推荐，除非是为了统一风格，针对单独的某个自定义View做更改会影响其他视图），可以采用自定义属性做到更改想要的效果而不影响其他的View（这个时候需要自己在调用super(…)之后将设定的属性值解析出来然后通过调用属性set函数设置到对应的代码属性之上）。 onFinishInflate():加载完XML组件后回调 onSizeChanged():组件大小改变时回调 onMeasure():回调该方法来进行测量（在该方法中实现对wrap_content支持的代码） onLayout():回调该方法来显示位置。在自定义ViewGroup中会用到，他调用的是子View的layout函数。onLayout一般是循环取出子View，然后经过计算得出各个子View位置的坐标值，然后用chid.layout(l,t,r,b)函数设置子View位置。 onTouchEvent():监听到触摸事件回调，也是实现交互非常重要的回调方法 onDraw():回调该方法对我们的控件进行绘制 注： onFinishInflite()或onAttachToWindow(): 可以得到子View对象 二. 3种自定义View 扩展式： 扩展式自定义View继承自Android原生特定的View如：TextView，ImageView等等。我们通过重写onDrow()等回调方法对其进行扩展！使其实现我们想要的功能或样式！ 注：该方法实现的自定义View控件不需要自己支持wrap_content和padding。 组合式： 组合式自定义View继承自ViewGrop的子View如：LinearLayout、RelativieLayout等。当某种效果看起来像几种View组合在一起的时候，都可以使用这种方式实现。 注：该方式实现自定义View不需要自己处理ViewGroup的测量和布局这两个过程。 完全自定义：完全自定义View继承自View（android中所有控件的基类），通常实现一些不方便布局的组合方式来达到的，需要静态或动态地显示一些不规则的控件或图形！ 注：**该方法实现的自定义View控件需要自己支持wrap_content和padding。** 三. 绘制流程-函数调用链 三. View生命周期123456789101112131415st=&gt;start: 可见性改变 or Activity.onCreate()op0=&gt;operation: 实例化View-调用View构造方法op1=&gt;operation: View.onFinishInflate()op2=&gt;operation: View.onAttachedToWindow()op3=&gt;operation: View.onMeasure()op4=&gt;operation: View.onSizeChanged()op5=&gt;operation: onLayout()op6=&gt;operation: onDraw()cond=&gt;condition: Activity.onDestroy()op=&gt;operation: View.onDetachedFromWindow()sub1=&gt;subroutine: 子流程1e=&gt;end: 结束框st-&gt;op0-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;condcond(yes)-&gt;op-&gt;econd(no)-&gt;e 四. 自定义步骤 自定义View的属性 在构造方法中获取自定义属性 重写onMesure(可根据情况省略这一步) 重写onDraw 注： 对于具有滑动效果的自定义View，还要做相关的滑动处理 如果遇到滑动冲突还需要解决相应的滑动冲突 第3步：(通常可以不重写该方法) 不重写：View这个类交给系统默认的处理 重写：如果View类的默认处理不满足我们的要求，我们就重写onMeasure函数 wrap_content或者是match_parent设置并没有指定真正的大小，可是我们绘制到屏幕上的View必须是要有具体的宽高，假如我们需要自顶一个正方形View这个时候必须对 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){ … } 进行重写。 1和2就省略了，从第三步开始。 五. 视需要重写onMeasure（设计宽高和测量模式）widthMeasureSpec, heightMeasureSpec都是int型，一个int有4字节存储空间。 所以，对这4字节即32bit划分可以表示多个信息：最高位2bit用于区分测量模式(2的2次方=4，完全可以涵盖UNSPECIFIED，EXACTLY，AT_MOST这3种测量模式)，后面30bit存放宽或高的大小信息。 12int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec); 注：其实以上两个方法内部就进行bit位隔开取的计算了(移位&lt;&lt;和且&amp;操作) 分析：此时获取的宽高的大小并不是最终绘制出来的大小，其大小来自父亲view的参考值。 测量模式 表示意思 UNSPECIFIED 父容器没有对当前View有任何限制，当前View可以任意取尺寸 EXACTLY 当前的尺寸就是当前View应该取的尺寸（固定值和 match_parent） AT_MOST 当前尺寸是当前View能取的最大尺寸（ wrap_content） 对wrap_content的支持 在onMeasure()方法中实现对wrap_content的支持 12345678910111213141516protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize= MeasureSpec.getSize(widthMeasureSpec); int heightSpectMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec); //这里就是对wrap_content的支持 if(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpectMode==MeasureSpec.AT_MOST)&#123; //这里设定的根据你自己自定义View的情况而定 setMeasuredDimension(200,200); &#125;else if(widthSpecMode==MeasureSpec.AT_MOST)&#123; setMeasuredDimension(200,heightSpecSize); &#125;else if (heightSpectMode==MeasureSpec.AT_MOST)&#123; setMeasuredDimension(widthSpecSize,200); &#125;&#125; 注： 不要调用super.onMeasure( widthMeasureSpec, heightMeasureSpec); 对padding的支持 在onDraw()方法中实现对padding的支持，其实就是在绘制控件时考虑到padding就好了。如果不自己实现那么你对该自定义View设置padding将是无效的！ 12345678910111213@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //这里是对画一个圆形的View的padding支持 final int paddingLeft = getPaddingLeft(); final int paddingRight = getPaddingRight(); final int paddingTop = getPaddingTop(); final int paddingBottom=getPaddingBottom(); int width = getWidth()-paddingLeft-paddingRight; int height = getHeight()-paddingBottom-paddingTop; int radius = Math.min(width,height)/2; canvas.drawCircle(paddingLeft+width/2,paddingTop+height/2,radius,mPaint_while);&#125; 六. 重写onDraw（实现效果）Canvas对象：画板 Canvas常用操作速查表： 操作分类 相关API 备注 绘制颜色 drawColor, drawRGB, drawARGB 使用单一颜色填充整个画布 绘制基本形状 drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧 绘制图片 drawBitmap, drawPicture 绘制位图和图片) 绘制文本 drawText, drawPosText, drawTextOnPath 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字 绘制路径 drawPath 绘制路径，绘制贝塞尔曲线时也需要用到该函数 顶点操作 drawVertices, drawBitmapMesh 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用 画布剪裁 clipPath, clipRect 设置画布的显示区域 画布快照 save, restore, saveLayerXxx, restoreToCount, getSaveCount 依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 会滚到指定状态、 获取保存次数 画布变换 translate, scale, rotate, skew 依次为 位移、缩放、 旋转、错切 Matrix(矩阵) getMatrix, setMatrix, concat 实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。 基础方法 getDensity, getWidth, getHeight，getDrawFilter，isHardwareAccelerated(API 11)，getMaximumBitmapWidth，getMaximumBitmapHeight，getDensity，quickReject，isOpaque，setBitmap，setDrawFilter 其他函数 Path常用操作速查表： 作用 相关API 备注 移动起点 moveTo 移动下一次操作的起点位置 设置终点 setLastPoint 重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同 连接直线 lineTo 添加上一个点到当前点之间的直线到Path 闭合路径 close 连接第一个点连接到最后一个点，形成一个闭合区域 添加内容 addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo 添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别) 是否为空 isEmpty 判断Path是否为空 是否为矩形 isRect 判断path是否是一个矩形 替换路径 set 用新的路径替换到当前路径所有内容 偏移路径 offset 对当前路径之前的操作进行偏移(不会影响之后的操作) 贝塞尔曲线 quadTo, cubicTo 分别为二次和三次贝塞尔曲线的方法 rXxx方法 rMoveTo, rLineTo, rQuadTo, rCubicTo 不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量) 填充模式 setFillType, getFillType, isInverseFillType, toggleInverseFillType 设置,获取,判断和切换填充模式 提示方法 incReserve 提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构) 布尔操作(API19) op 对两个Path进行布尔运算(即取交集、并集等操作) 计算边界 computeBounds 计算Path的边界 重置路径 reset, rewind 清除Path中的内容 reset不保留内部数据结构，但会保留FillType. rewind会保留内部的数据结构，但不保留FillType 矩阵操作 transform 矩阵变换 Matrix常用操作速查表： 方法类别 相关API 备注 基本方法 equals hashCode toString toShortString 比较、 获取哈希值、 转换为字符串 数值操作 set reset setValues getValues 设置、 重置、 设置数值、 获取数值 数值计算 mapPoints mapRadius mapRect mapVectors 计算变换后的数值 设置(set) setConcat setRotate setScale setSkew setTranslate 设置变换 前乘(pre) preConcat preRotate preScale preSkew preTranslate 前乘变换 后乘(post) postConcat postRotate postScale postSkew postTranslate 后乘变换 特殊方法 setPolyToPoly setRectToRect rectStaysRect setSinCos 一些特殊操作 矩阵相关 invert isAffine(API21) isIdentity 求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵 … 贝塞尔曲线常用操作速查表： 贝塞尔曲线 对应的方法 演示动画 一阶曲线(线性曲线) lineTo 二阶曲线 quadTo 三阶曲线 cubicTo 四阶曲线 无 自定义View的延伸：自定义ViewGroup 设计思路: 1.首先，我们得知道各个子View的大小吧，只有先知道子View的大小，我们才知道当前的ViewGroup该设置为多大去容纳它们。 2.根据子View的大小，以及我们的ViewGroup要实现的功能，决定出ViewGroup的大小 3.ViewGroup和子View的大小算出来了之后，接下来就是去摆放了吧，具体怎么去摆放呢？这得根据你定制的需求去摆放了，比如，你想让子View按照垂直顺序一个挨着一个放，或者是按照先后顺序一个叠一个去放，这是你自己决定的。 4.已经知道怎么去摆放还不行啊，决定了怎么摆放就是相当于把已有的空间”分割”成大大小小的空间，每个空间对应一个子View，我们接下来就是把子View对号入座了，把它们放进它们该放的地方去。 步骤：(实现ViewGroup垂直摆放child view) 重写onMeasure，实现测量子View大小以及设定ViewGroup的大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //将所有的子View进行测量，这会触发每个子View的onMeasure函数 //注意要与measureChild区分，measureChild是对单个view进行测量 measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int childCount = getChildCount(); if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间 setMeasuredDimension(0, 0); &#125; else &#123; //如果宽高都是包裹内容 if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度 int height = getTotleHeight(); int width = getMaxChildWidth(); setMeasuredDimension(width, height); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容 //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和 setMeasuredDimension(widthSize, getTotleHeight()); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容 //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值 setMeasuredDimension(getMaxChildWidth(), heightSize); &#125; &#125; &#125; /*** * 获取子View中宽度最大的值 */ private int getMaxChildWidth() &#123; int childCount = getChildCount(); int maxWidth = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if (childView.getMeasuredWidth() &gt; maxWidth) maxWidth = childView.getMeasuredWidth(); &#125; return maxWidth; &#125; /*** * 将所有子View的高度相加 **/ private int getTotleHeight() &#123; int childCount = getChildCount(); int height = 0; for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); height += childView.getMeasuredHeight(); &#125; return height; &#125; 摆放child View 123456789101112131415@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); //记录当前的高度位置 int curHeight = t; //将子View逐个摆放 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); int height = child.getMeasuredHeight(); int width = child.getMeasuredWidth(); //摆放子View，参数分别是子View矩形区域的左、上、右、下边 child.layout(l, curHeight, l + width, curHeight + height); curHeight += height; &#125; &#125; 参看文章： Developers 自定义View，有这一篇就够了 自定义view总结 自定义View之总结 自定义View（三）—自定义View整个流程的梳理与总结 - 李诗雨 引申： Android 自定义View (二) 进阶 - Hongyang) Android: draw a custom view - Roman Danylyk (Medium) HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础 自定义View分类与流程 GcsSloop 深度解析View构造函数中的参数defStyleAttr View的生命周期方法和Activity生命周期方法关系]]></content>
      <tags>
        <tag>views</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interview Resources]]></title>
    <url>%2F2018%2F03%2F27%2FInterview-Resources%2F</url>
    <content type="text"><![CDATA[资料： louyutong]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java VM]]></title>
    <url>%2F2018%2F03%2F27%2FJava-VM%2F</url>
    <content type="text"><![CDATA[注： 转自Java JVM 运行机制及基本原理 - 韦庆明 将知识用文字记录下来，供以后温故知新。 JVM的基础概念JVM的中文名称叫Java虚拟机，它是由软件技术模拟出计算机运行的一个虚拟的计算机。 JVM也充当着一个翻译官的角色，我们编写出的Java程序，是不能够被操作系统所直接识别的，这时候JVM的作用就体现出来了，它负责把我们的程序翻译给系统“听”，告诉它我们的程序需要做什么操作。 我们都知道Java的程序需要经过编译后，产生.Class文件，JVM才能识别并运行它，JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因。 JVM的生命周期JVM在Java程序开始执行的时候，它才运行，程序结束的时它就停止。 一个Java程序会开启一个JVM进程，如果一台机器上运行三个程序，那么就会有三个运行中的JVM进程。 JVM中的线程分为两种：守护线程和普通线程 守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。 普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。 权限足够的话，可以调用exit()方法终止程序。 JVM的结构体系 JVM的启动过程1、JVM的装入环境和配置 在学习这个之前，我们需要了解一件事情，就是JDK和JRE的区别。 JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境，JDK中包含了JRE。 JRE是Java的运行环境，是面向所有Java程序的使用者，包括开发者。 JRE = 运行环境 = JVM。 如果安装了JDK，会发现电脑中有两套JRE，一套位于/Java/jre…/下，一套位于/Java/jdk…/jre下。那么问题来了，一台机器上有两套以上JRE，谁来决定运行那一套呢？这个任务就落到java.exe身上，java.exe的任务就是找到合适的JRE来运行java程序。 java.exe按照以下的顺序来选择JRE： 1、自己目录下有没有JRE 2、父目录下有没有JRE 3、查询注册表： HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\”当前JRE版本号”\JavaHome 这几步的主要核心是为了找到JVM的绝对路径。 jvm.cfg的路径为：JRE路径\lib\”CPU架构”\jvm.fig jvm.cfg的内容大致如下： -client KNOWN -server KNOWN -hotspot ALIASED_TO -client -classic WARN -native ERROR -green ERROR KNOWN 表示存在 、IGNORE 表示不存在 、ALIASED_TO 表示给别的JVM去一个别名 WARN 表示不存在时找一个替代 、ERROR 表示不存在抛出异常 2、装载JVM 通过第一步找到JVM的路径后，Java.exe通过LoadJavaVM来装入JVM文件。LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。3、初始化JVM，获得本地调用接口 调用InvocationFunction -&gt; CreateJavaVM也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例。4、运行Java程序 JVM运行Java程序的方式有两种：jar包 与 Class运行jar 的时候，Java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用JarFileJNIEnv类中getManifest()，从其返回的Manifest对象中取getAttrebutes(“Main-Class”)的值，即jar 包中文件：META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。运行Class的时候，main函数直接调用Java.c中的LoadClass方法装载该类。 Class文件Class文件由Java编译器生成，我们创建的.Java文件在经过编译器后，会变成.Class的文件，这样才能被JVM所识别并运行。 类加载子系统类加载子系统也可以称之为类加载器，JVM默认提供三个类加载器： 1、BootStrap ClassLoader ：称之为启动类加载器，是最顶层的类加载器，负责加载JDK中的核心类库，如 rt.jar、resources.jar、charsets.jar等。 2、Extension ClassLoader：称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。 3、App ClassLoader：称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。 除了Java默认提供的三个ClassLoader（加载器）之外，我们还可以根据自身需要自定义ClassLoader，自定义ClassLoader必须继承java.lang.ClassLoader 类。除了BootStrap ClassLoader 之外的另外两个默认加载器都是继承自java.lang.ClassLoader 。BootStrap ClassLoader 不是一个普通的Java类，它底层由C++编写，已嵌入到了JVM的内核当中，当JVM启动后，BootStrap ClassLoader 也随之启动，负责加载完核心类库后，并构造Extension ClassLoader 和App ClassLoader 类加载器。 类加载器子系统不仅仅负责定位并加载类文件，它还严格按照以下步骤做了很多事情： 1234561、加载：寻找并导入Class文件的二进制信息2、连接：进行验证、准备和解析 1）验证：确保导入类型的正确性 2）准备：为类型分配内存并初始化为默认值 3）解析：将字符引用解析为直接引用3、初始化：调用Java代码，初始化类变量为指定初始值 详细请参考另一篇文章：Java类加载机制 - 知乎专栏 方法区（Method Area）在JVM中，类型信息和类静态变量都保存在方法区中，类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。 需要注意的一点是，常量池也存放于方法区中。 程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。 在程序运行时，方法区的大小是可以改变的，程序在运行时可以扩展。 方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下，详情可以参考另一篇文章：Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏 类型信息包括什么？ 1234567891011121314151617181920211、类型的全名（The fully qualified name of the type）2、类型的父类型全名（除非没有父类型，或者父类型是java.lang.Object）（The fully qualified name of the typeís direct superclass）3、该类型是一个类还是接口（class or an interface）（Whether or not the type is a class ）4、类型的修饰符（public，private，protected，static，final，volatile，transient等）（The typeís modifiers）5、所有父接口全名的列表（An ordered list of the fully qualified names of any direct superinterfaces）6、类型的字段信息（Field information）7、类型的方法信息（Method information）8、所有静态类变量（非常量）信息（All class (static) variables declared in the type, except constants）9、一个指向类加载器的引用（A reference to class ClassLoader）10、一个指向Class类的引用（A reference to class Class）11、基本类型的常量池（The constant pool for the type） 方法列表（Method Tables） 为了更高效的访问所有保存在方法区中的数据，在方法区中，除了保存上边的这些类型信息之外，还有一个为了加快存取速度而设计的数据结构：方法列表。每一个被加载的非抽象类，Java虚拟机都会为他们产生一个方法列表，这个列表中保存了这个类可能调用的所有实例方法的引用，保存那些父类中调用的方法。 Java堆（JVM堆、Heap）当Java创建一个类的实例对象或者数组时，都在堆中为新的对象分配内存。 虚拟机中只有一个堆，程序中所有的线程都共享它。 堆占用的内存空间是最多的。 堆的存取类型为管道类型，先进先出。 在程序运行中，可以动态的分配堆的内存大小。 堆的内存资源回收是交给JVM GC进行管理的，详情请参考：Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏 Java栈（JVM栈、Stack）在Java栈中只保存基础数据类型（参考：Java 基本数据类型 - 四类八种 - 知乎专栏）和自定义对象的引用，注意只是对象的引用而不是对象本身哦，对象是保存在堆区中的。 拓展知识：像String、Integer、Byte、Short、Long、Character、Boolean这六个属于包装类型，它们是存放于堆中的。 栈的存取类型为类似于水杯，先进后出。 栈内的数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理。 每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。 每个线程都会建立一个操作栈，每个栈又包含了若干个栈帧，每个栈帧对应着每个方法的每次调用，每个栈帧包含了三部分： 局部变量区（方法内基本类型变量、变量对象指针） 操作数栈区（存放方法执行过程中产生的中间结果） 运行环境区（动态连接、正确的方法返回相关信息、异常捕捉） 本地方法栈本地方法栈的功能和JVM栈非常类似，用于存储本地方法的局部变量表，本地方法的操作数栈等信息。 栈的存取类型为类似于水杯，先进后出。 栈内的数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理。 每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。 本地方法栈是在程序调用或JVM调用本地方法接口（Native）时候启用。 本地方法都不是使用Java语言编写的，比如使用C语言编写的本地方法，本地方法也不由JVM去运行，所以本地方法的运行不受JVM管理。 HotSpot VM将本地方法栈和JVM栈合并了。 程序计数器在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。 程序计数器仅占很小的一块内存空间。 当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。 程序计数器这个内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。 JVM执行引擎Java虚拟机相当于一台虚拟的“物理机”，这两种机器都有代码执行能力，其区别主要是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。而JVM的执行引擎是自己实现的，因此程序员可以自行制定指令集和执行引擎的结构体系，因此能够执行那些不被硬件直接支持的指令集格式。 在JVM规范中制定了虚拟机字节码执行引擎的概念模型，这个模型称之为JVM执行引擎的统一外观。JVM实现中，可能会有两种的执行方式：解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码）。有些虚拟机只采用一种执行方式，有些则可能同时采用两种，甚至有可能包含几个不同级别的编译器执行引擎。 输入的是字节码文件、处理过程是等效字节码解析过程、输出的是执行结果。在这三点上每个JVM执行引擎都是一致的。 本地方法接口（JNI）JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C和C++）。 JNI的适用场景 当我们有一些旧的库，已经使用C语言编写好了，如果要移植到Java上来，非常浪费时间，而JNI可以支持Java程序与C语言编写的库进行交互，这样就不必要进行移植了。或者是与硬件、操作系统进行交互、提高程序的性能等，都可以使用JNI。需要注意的一点是需要保证本地代码能工作在任何Java虚拟机环境。 JNI的副作用 一旦使用JNI，Java程序将丢失了Java平台的两个优点： 1、程序不再跨平台，要想跨平台，必须在不同的系统环境下程序编译配置本地语言部分。 2、程序不再是绝对安全的，本地代码的使用不当可能会导致整个程序崩溃。一个通用规则是，调用本地方法应该集中在少数的几个类当中，这样就降低了Java和其他语言之间的耦合。 JVM GC（垃圾回收机制）详情请参考我的另外一篇文章：Java性能优化之JVM GC（垃圾回收机制） - 知乎专栏 JVM 常量池JVM常量池也称之为运行时常量池，它是方法区（Method Area）的一部分。用于存放编译期间生成的各种字面量和符号引用。运行时常量池不要求一定只有在编译器产生的才能进入，运行期间也可以将新的常量放入池中，这种特性被开发人员利用比较多的就是String.intern()方法。 由“**用于存放编译期间生成的各种字面量和符号引用”这句话可见，常量池中存储的是对象的引用而不是对象的本身**。 常量池的好处 常量池是为了避免频繁的创建和销毁对象而影响系统性能，它也实现了对象的共享。 例如字符串常量池：在编译阶段就把所有字符串文字放到一个常量池中。 1、节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。 2、节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，==判断引用是否相等，也就可以判断实际值是否相等。 双等号（==）的含义 基本数据类型之间使用双等号，比较的是数值。 复合数据类型（类）之间使用双等号，比较的是对象的引用地址是否相等。 八种基本类型的包装类和常量池 Byte、Short、Integer、Long、Character、Boolean、String这7种包装类都各自实现了自己的常量池。 1234//例子：Integer i1 = 20;Integer i2 = 20;System.out.println(i1=i2);//输出TRUE Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。当对这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。 1234567//IntegerCache.low = -128//IntegerCache.high = 127public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 1234//例子Integer i1 = 200;Integer i2 = 200;System.out.println(i1==i2);//返回FALSE Float 和Double 没有实现常量池。 String包装类与常量池 1String str1 = &quot;aaa&quot;; 当以上代码运行时，JVM会到字符串常量池查找 “aaa” 这个字面量对象是否存在？ 存在：则返回该对象的引用给变量 str1 。 不存在：则在堆中创建一个相应的对象，将创建的对象的引用存放到常量池中，同时将引用返回给变量 str1 。 123String str1 = &quot;aaa&quot;;String str2 = &quot;aaa&quot;;System.out.println(str1 == str2);//返回TRUE 因为变量str1 和str2 都指向同一个对象，所以返回true。 12String str3 = new String(&quot;aaa&quot;);System.out.println(str1 == str3);//返回FALSE 当我们使用了new来构造字符串对象的时候，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建。因为两个指向的是不同的对象，所以返回FALSE 。 String.intern()方法 对于使用了new 创建的字符串对象，如果想要将这个对象引用到字符串常量池，可以使用intern() 方法。 调用intern() 方法后，检查字符串常量池中是否有这个对象的引用，并做如下操作： 存在：直接返回对象引用给变量。 不存在：将这个对象引用加入到常量池，再返回对象引用给变量。 12String interns = str3.intern();System.out.println(interns == str1);//返回TRUE 假定常量池中都没有以上字面量的对象，以下创建了多少个对象呢？ 123String str4 = &quot;abc&quot;+&quot;efg&quot;;String str5 = &quot;abcefg&quot;;System.out.println(str4 == str5);//返回TRUE 答案是三个。第一个：”abc” ，第一个：”efg”，第三个：”abc”+”efg”（”abcefg”） String str5 = “abcefg”; 这句代码并没有创建对象，它从常量池中找到了”abcefg” 的引用，所有str4 == str5 返回TRUE，因为它们都指向一个相同的对象。 什么情况下会将字符串对象引用自动加入字符串常量池？ 1234567891011//只有在这两种情况下会将对象引用自动加入到常量池String str1 = &quot;aaa&quot;;String str2 = &quot;aa&quot;+&quot;a&quot;;//其他方式下都不会将对象引用自动加入到常量池，如下：String str3 = new String(&quot;aaa&quot;);String str4 = New StringBuilder(&quot;aa&quot;).append(&quot;a&quot;).toString();StringBuilder sb = New StringBuilder();sb.append(&quot;aa&quot;);sb.append(&quot;a&quot;);String str5 = sb.toString(); 好了，JVM的基本原理就写到这里，以后更深入的了解后会再来补充。]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View Hierarchy and View Events]]></title>
    <url>%2F2018%2F03%2F27%2FView-Hierarchy-and-View-Events%2F</url>
    <content type="text"><![CDATA[事件概述(窗口机制)：事件由硬件感应,会被Android系统(基于Linux)存储在/dev/input/各个目录下(event0,event1..),然后由WindowManagerService捕获用户输入的事件(按键/触摸),WMS通过共享内存和管道的方式传递给ViewRoot(ViewRoot extends Handler),ViewRoot再dispatch给Application的View. 当有事件从硬件设备输入时,system_service端检测到事件发生时,通过管道通知ViewRoot事件发生,此时ViewRoot再去内存中读取这个事件信息.WindowManagerService-&gt;ViewRoot(ViewRoot extends Handler implements ViewParent)-&gt;Activity(-&gt;PhoneWindow直接执行的是mDecor的分发分发)-&gt;DecorView(PhoneWindow的子类);另:(WindowManager为接口,定义管理PhoneWindow的接口) Activity之setContentViewDecorView继承于FrameLayout，然后它有一个子view即LinearLayout，方向为竖直方向，其内有两个FrameLayout，上面的FrameLayout即为TitleBar之类的，下面的FrameLayout即为我们的ContentView，所谓的setContentView就是往这个FrameLayout里面添加我们的布局View的！ 事件的派发过程：WindowManagerService -&gt; Activity -&gt; DecorView(PhoneWindow的子类) -&gt; ViewGroup -&gt; View 简述为: Activity -&gt; ViewGroup -&gt; View 事件处理过程： 事件截断处理的View: onInterceptTouchEvent() return true;(表示不再向子View传递事件,否则传递给子View[当其最里面的子View 的dispatchTouchEvent()返回为false则继续原路返回往外传递]) 事件分发处理的View: dispatchTouchEvent() return true;(表示当前View要处理[返回true是告诉父View被 我/我的子View 处理了,处理的过程是 我/我的子View 调用onTouchEvent()而且返回true处理的],反之则自己不处理分发给子View) 事件消费处理的View: onTouchEvent() return true;(表示事件的终点,否则则不是终点.注: 如果都不处理最后会由Activity返回false作为最后一个调用者,不可点击的View只能返回false) 伪代码逻辑: if(ViewGroup.onInterceptTouchEvent()==false ) { View.dispatchTouchEvent() } if(View.onTouchEvent()==true ) { View.dispatchTouchEvent()-&gt; ViewGroup.dispatchTouchEvent()-&gt; Activity.dispatchTouchEvent() } if(View.onTouchEvent()==false ) { ViewGroup.onTouchEvent()-&gt; Activity.onTouchEvent() } if(ViewGroup.onInterceptTouchEvent()==true ) { ViewGroup.onTouchEvent()} 只进行第一次判断为true, 下次用户再点击不会再调用ViewGroup.onInterceptTouchEvent(),而是直接调用ViewGroup.onTouchEvent(), 因为多于的判断没有意义(其拦截函数返回都是true) if(ViewGroup.onTouchEvent()==true ){ if(View.onTouchEvent()==true&amp;&amp;action == ACTION_DOWN) { if(某一刻 ViewGroup.onInterceptTouchEvent()==true) 那么下次子View就会收到一个ACTION_CANCEL } } 资料： Android完美解析setContentView 你真的理解setContentView吗？ android的窗口机制分析——事件处理 Android中与ViewRoot相关的一些概念 《深入理解Android 卷III》第四章 深入理解WindowManagerService 使用WindowManager添加View——悬浮窗口的基本原理]]></content>
      <tags>
        <tag>view&amp;event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adb Dumpsys]]></title>
    <url>%2F2018%2F03%2F26%2FAdb-Dumpsys%2F</url>
    <content type="text"><![CDATA[1. 查看帮助adb shell dumpsys -h Activity manager dump options:[-a][-c] [-p package][-h] [cmd] …//省略处为可以跟的参数(有-a/-c/-p)cmd may be one of://代表可以跟的命令a[ctivities]: activity stack state//activity的栈信息r[recents]: recent activities state//最新的activity的信息b[roadcasts][PACKAGE_NAME] [history [-s]]: broadcast statei[ntents][PACKAGE_NAME]: pending intent statep[rocesses][PACKAGE_NAME]: process stateo[om]: out of memory managementperm[issions]: URI permission grant stateprov[iders] [COMP_SPEC …]: content provider stateprovider [COMP_SPEC]: provider client-side states[ervices] [COMP_SPEC …]: service stateas[sociations]: tracked app associationsservice [COMP_SPEC]: service client-side statepackage [PACKAGE_NAME]: all state related to given packageall: dump all activitiestop: dump the top activitywrite: write all pending state to storagetrack-associations: enable association trackinguntrack-associations: disable and clear association trackingcmd may also be a COMP_SPEC to dump activities.COMP_SPEC may be a component name (com.foo/.myApp),a partial substring in a component name, ahex object identifier.-a: include all available server state.-c: include client state.-p: limit output to given package. 2. 常见命令 adb shell dumpsys activity top显示处于前台activity(活动状态的栈顶)的信息。 adb shell dumpsys activity | grep “xxx”过滤目前的所有的activity栈信息。 adb shell dumpsys activity -p “包名”过滤某个包的信息。 dumpsys命令很强大，可以慢慢探索。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Some Git Commands]]></title>
    <url>%2F2018%2F03%2F26%2FSome-Git-Commands%2F</url>
    <content type="text"><![CDATA[1. 常用命令 git branch &lt;新分支名&gt; //创建新分支 git checkout &lt;分支名&gt; //切换到某分支 git checkout -b &lt;新分支名&gt; &lt;基于分支&gt; //先基于分支创建新分支，再切换到新分支(基于分支可以是从远端取过来的缓存分支,如：origin/master) git push &lt;远端名&gt; &lt;本地分支&gt;：&lt;远端分支&gt; //推送本地提交到远端(如省掉本地分支，含义变为删除远端分支) git pull &lt;远端名&gt; &lt;远端分支&gt;：&lt;本地分支&gt; //拉取远端分支更新到本地，再合并到本地分支(如果是要合并到当前分支，则可以省略”:&lt;本地分支&gt;”) git fetch &lt;远端名&gt; &lt;远端分支&gt; //如果省略远端分支则会取回所有远端分支(所有取回的分支则会以”origin/分支”命名) git merge &lt;本地缓存分支&gt; //本地缓存分支形如”origin/分支” git rebase &lt;本地缓存分支&gt; //本地缓存分支形如”origin/分支”, 含义同git merge但是不保留merge的痕迹 2. 关联仓库有两种方式：A) git clone &lt;本地文件夹&gt;B) git initgit remote add &lt;远端名&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sorting Algorithm]]></title>
    <url>%2F2018%2F03%2F23%2FSorting-Algorithm%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Regular expression]]></title>
    <url>%2F2018%2F03%2F23%2FRegular-expression%2F</url>
    <content type="text"><![CDATA[语法如图所示:重点总结: 中括号: 逐个列举的作用, 可以用连字符表示一个范围, 第一个位置可以取保留字意义, 如果是^表示将其后一串字符取非, 其他位置则一律是字符本义(没有赋予特殊表达或象征含义); 所以要使用象征含义可以使用反斜杠”\”致使系统识别起作用 小括号: 被括起来的字符作为一个分组, 会依次从1开始由左至右编号 大括号: 表匹配前一个字符(串)的次数 ?: 匹配前一个字符(串)的0或1次, 可以有效防止贪婪匹配(如: *?; +?; {m,n}?) \数字: 引用分组字符串(数字即某个位置的小括号的数字编号, 再重用它内部的字符串于\数字出现处) ?P&lt;别名&gt;: 给其后字符起别名组别(非数字式) ?P=别名: 以别名方式调用组别字符串 (?:字符串1|字符串2): 不分组, 但是可以表达多个或的匹配含义 (?#注释): 忽略注释部分内容 (?&lt;=前移字符串): 前面的字符要符合这个前移字符串(记忆: &lt;=表示往前推进一位, 所以是前置匹配) (?=之后串): 之后的字符要符合这个之后串(记忆: 不用指明方向则默认是后置匹配) (?!字符串): 之后的字符要不符合这个串通过 (?&lt;!): 同上 (?(组名)yes时再匹配串|no时再匹配串): 当引用组的匹配能发生(或者不成功)时, 还需要匹配的东西是yes(或no)串, 两者都符合才算整体匹配成功.]]></content>
      <tags>
        <tag>Required skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sorting Algorithms]]></title>
    <url>%2F2018%2F03%2F23%2FSorting-Algorithms%2F</url>
    <content type="text"><![CDATA[记忆:nn: 选择-&gt;插入-&gt;冒泡 nlog(2)n: 快速-&gt;归并-&gt;堆排 (shell排-&gt;基排-&gt;桶排) 时间复杂度: 注： 1、归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间， 2、快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念： 1、时间复杂度 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2) 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1), 2、空间复杂度 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1) 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n) ax=N，则x=logaN， 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n). 引自AmyAlisa 一. 选择排序代码实现： 首先确定循环次数，并且记住当前数字和当前位置。将当前位置后面所有的数与当前数字进行对比，小数赋值给key，并记住小数的位置。比对完成后，将最小的值与第一个数的值交换。重复2、3步。 分析: 选择排序重点在于挑选出最值作一次交换, 而不需挪动多个完成一趟循环(但是每趟循环还是会对每个元素作比较). 所以, 逻辑是这样 – 遍历整个序列，将最小的数放在最前面。遍历剩下的序列，将最小的数放在最前面。重复第二步，直到只剩下一个数。 if(a[j] &lt; val) { val = a[j]; pos = j;}//只要一看到小的值, 就用它覆盖掉自己充当小人物, 并记录下标. for(int j=i+1; j&lt;len; j++){ 1. }//因为是将挑到的最小值放在前面, 所以j的每次起点要记得挪位. int val = a[i]; int pos = i; for(int i: 0~len-1) 二. 插入排序代码实现： 首先设定插入次数，即循环次数，for(int i=1;i&lt;length;i++)，1个数的那次不用插入。设定插入数和得到已经排好序列的最后一个数的位数。insertNum和j=i-1。从最后一个数开始向前循环，如果插入数小于当前数，就将当前数向后移动一位。将当前数放置到空着的位置，即j+1。 分析: 对待排的一组数, 假设前面第一个数是排好顺序的, 现在要把后面的数据依次插入, 每次插入都能构成一个新的有序序列, 直到把所有数据插入排序顺序. while(a[j] &gt; insert &amp;&amp; j&gt;=0){ a[j+1] = a[j]; j–;}//从已排好序列的末尾开始, 若当前位置的数值若大于待插入元素值, 将其后挪一位, 循序比较, 如果所有数都大于待插入数值, 则比较到第一位0号元素. { 1. } a[j+1] = insert; int j=i-1; insert = a[i]; for(int i:1~len-1)//从1开始是因为, 加入数组只有一个则不用排 int len = a.length; int insert; 三. 冒泡排序代码实现： 设置循环次数。设置开始比较的位数，和结束的位数。两两比较，将最小的放到前面去。重复2、3步，直到循环次数完毕。 分析: 其实思想就是这么个事情, 记住了也不一定能一下写出来, 为什么? 那是由于你的代码转换思维能力的发挥. if(a[j] &gt; a[j+1]) { int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp;} for(int j=o; j&lt;n-1 - i; j++){ 1. } for(int i=0; i&lt;n; i++) 四. 快速排序代码思路: 要求时间最快时。选择第一个数为p，小于p的数放在左边，大于p的数放在右边。递归的将p左边和右边的数都按照第一步进行，直到不能递归。 分析: 分治也就是化整为零, 分成小块-&gt;小块排好-&gt;整体排好 void partition(int s[], int start, int end)//分治挖坑 while(s[j] &gt;= x &amp;&amp; i&lt;j) j–;//从右开水找小于x的(因为不符合的就是小于的数)数据来填a[i] if(i&lt;j) { s[i] = s[j]; i++;}//将找到的s[j]填入s[i], 是s[j]就会形成一个新的坑 while(s[i] =的数)数来填s[j] if(i&lt;j) { s[j] = s[i]; j–;}//将找到的s[i]填入s[j], 是s[i]就会形成一个新的坑 while(i4.;}//外层循环 s[i] = x;//i和j相遇了, 此时i==j; 记得将基准值插入最后停留的位置(任何位置都可能, 取决于数据组) int i = start; j = end; int x = s[start]; {5-&gt;6.} return i;//将i返回给作为新的基准位置 void quickSort(int s[], int start, int end)//快排递归 if(start&lt;end){ int baseIndex = partition(s,start,end); quickSort(s, start, baseIndex - 1); quickSort(s, baseIndex+1, end);}//使用递归将每次的分治规模减小, 知道所有数据排好顺序 注： baseIndex=privot=x; 五. 归并排序 速度仅次于快排，内存少的时候使用，可以进行并行计算的时候使用。 代码思路： 选择相邻两个数组成一个有序序列。 选择相邻的两个有序序列组成一个有序序列。 重复第二步，直到全部组成一个有序序列。 代码： 12345678910111213141516171819202122232425262728293031323334353637public static void mergeSort(int[] numbers, int left, int right) &#123; int t = 1;// 每组元素个数 int size = right - left + 1; while (t &lt; size) &#123; int s = t;// 本次循环每组元素个数 t = 2 * s; int i = left; while (i + (t - 1) &lt; size) &#123; merge(numbers, i, i + (s - 1), i + (t - 1)); i += t; &#125; if (i + (s - 1) &lt; right) merge(numbers, i, i + (s - 1), right); &#125; &#125; private static void merge(int[] data, int p, int q, int r) &#123; int[] B = new int[data.length]; int s = p; int t = q + 1; int k = p; while (s &lt;= q &amp;&amp; t &lt;= r) &#123; if (data[s] &lt;= data[t]) &#123; B[k] = data[s]; s++; &#125; else &#123; B[k] = data[t]; t++; &#125; k++; &#125; if (s == q + 1) B[k++] = data[t++]; else B[k++] = data[s++]; for (int i = p; i &lt;= r; i++) data[i] = B[i]; &#125; 六. 堆排序 对简单选择排序的优化。 代码思路： 将序列构建成大顶堆。 将根节点与最后一个节点交换，然后断开最后一个节点。 重复第一、二步，直到所有节点断开。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void heapSort(int[] a)&#123; System.out.println(&quot;开始排序&quot;); int arrayLength=a.length; //循环建堆 for(int i=0;i&lt;arrayLength-1;i++)&#123; //建堆 buildMaxHeap(a,arrayLength-1-i); //交换堆顶和最后一个元素 swap(a,0,arrayLength-1-i); System.out.println(Arrays.toString(a)); &#125; &#125; private void swap(int[] data, int i, int j) &#123; // TODO Auto-generated method stub int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125; //对data数组从0到lastIndex建大顶堆 private void buildMaxHeap(int[] data, int lastIndex) &#123; // TODO Auto-generated method stub //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125; 七. Shell排序 对于直接插入排序问题，数据量巨大时。 代码思路： 将数的个数设为n，取奇数k=n/2，将下标差值为k的书分为一组，构成有序序列。 再取k=k/2 ，将下标差值为k的书分为一组，构成有序序列。 重复第二步，直到k=1执行简单插入排序。 代码实现： 如何写成代码： 首先确定分的组数。 然后对组中元素进行插入排序。 然后将length/2，重复1,2步，直到length=0为止。 代码： 12345678910111213141516public void sheelSort(int[] a)&#123; int d = a.length; while (d!=0) &#123; d=d/2; for (int x = 0; x &lt; d; x++) &#123;//分的组数 for (int i = x + d; i &lt; a.length; i += d) &#123;//组中的元素，从第二个数开始 int j = i - d;//j为有序序列最后一位的位数 int temp = a[i];//要插入的元素 for (; j &gt;= 0 &amp;&amp; temp &lt; a[j]; j -= d) &#123;//从后往前遍历。 a[j + d] = a[j];//向后移动d位 &#125; a[j + d] = temp; &#125; &#125; &#125; &#125; 八. 基数排序代码思路： 用于大量数，很长的数进行排序时。 将所有的数的个位数取出，按照个位数进行排序，构成一个序列。 将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public void baseSort(int[] a) &#123; //首先确定排序的趟数; int max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; int time = 0; //判断位数; while (max &gt; 0) &#123; max /= 10; time++; &#125; //建立10个队列; List&lt;ArrayList&lt;Integer&gt;&gt; queue = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; ArrayList&lt;Integer&gt; queue1 = new ArrayList&lt;Integer&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for (int i = 0; i &lt; time; i++) &#123; //分配数组元素; for (int j = 0; j &lt; a.length; j++) &#123; //得到数字的第time+1位数; int x = a[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); ArrayList&lt;Integer&gt; queue2 = queue.get(x); queue2.add(a[j]); queue.set(x, queue2); &#125; int count = 0;//元素计数器; //收集队列元素; for (int k = 0; k &lt; 10; k++) &#123; while (queue.get(k).size() &gt; 0) &#123; ArrayList&lt;Integer&gt; queue3 = queue.get(k); a[count] = queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125; &#125; 九. 桶排代码思路： 桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等长地分到10000个虚拟的“桶”里面，这样，平均每个桶只有10000个数。如果每个桶都有序了，则只需要依次输出为有序序列即可。具体思路是这样的： 1.将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布；实际上，通常采用的方法都做不到这一点。显然，对于一个已知输入范围在【0，10000】的数组，最简单的分段方法莫过于x/m这种方法，例如，f(x)=x/100。 “连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。 2.分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。 3.对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。 4.按顺序从每个桶输出数据。例如，1号桶【112，123，145，189】，2号桶【234，235，250，250】，3号桶【361】，则输出序列为【112，123，145，189，234，235，250，250，361】。 5.排序完成。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void bucketSort(int[] arr)&#123; //分桶，这里采用映射函数f(x)=x/10。 //输入数据为0~99之间的数字 int bucketCount =10; Integer[][] bucket = new Integer[bucketCount][arr.length]; //Integer初始为null,以与数字0区别。 for (int i=0; i&lt;arr.length; i++)&#123; int quotient = arr[i]/10; //这里即是使用f(x) for (int j=0; j&lt;arr.length; j++)&#123; if (bucket[quotient][j]==null)&#123; bucket[quotient][j]=arr[i]; break; &#125; &#125; &#125; //小桶排序 for (int i=0; i&lt;bucket.length; i++)&#123; //insertion sort for (int j=1; j&lt;bucket[i].length; ++j)&#123; if(bucket[i][j]==null)&#123; break; &#125; int value = bucket[i][j]; int position=j; while (position&gt;0 &amp;&amp; bucket[i][position-1]&gt;value)&#123; bucket[i][position] = bucket[i][position-1]; position--; &#125; bucket[i][position] = value; &#125; &#125; //输出 for (int i=0, index=0; i&lt;bucket.length; i++)&#123; for (int j=0; j&lt;bucket[i].length; j++)&#123; if (bucket[i][j]!=null)&#123; arr[index] = bucket[i][j]; index++; &#125; else&#123; break; &#125; &#125; &#125;&#125; 参考文章: Java常用的八种排序算法与代码实现 一遍记住 Java 常用的八种排序算法与代码实现 白话经典算法系列之六 快速排序 快速搞定 用Java写算法之八：桶排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Graph]]></title>
    <url>%2F2018%2F03%2F18%2FGraph%2F</url>
    <content type="text"><![CDATA[转自这 一、基本术语 图（graph）：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。 顶点(Vertex)：图中的数据元素。线性表中我们把数据元素叫元素，树中将数据元素叫结点。 边：顶点之间的逻辑关系用边来表示，边集可以是空的。 无向边(Edge)：若顶点V1到V2之间的边没有方向，则称这条边为无向边。 无向图(Undirected graphs)：图中任意两个顶点之间的边都是无向边。（A,D）=（D,A） 1对于无向图G来说，G1=（V1,&#123;E1&#125;），其中顶点集合V1=&#123;A,B,C,D&#125;；边集和E1=&#123;（A,B），（B,C），（C,D），（D,A），（A,C）&#125; 有向边：若从顶点V1到V2的边有方向，则称这条边为有向边，也称弧(Arc)。用表示，V1为狐尾(Tail)，V2为弧头(Head)。（V1，V2）≠（V2，V1）。有向图(Directed graphs)：图中任意两个顶点之间的边都是有向边。 注意：无向边用“（）”，而有向边用“&lt; &gt;”表示。简单图：图中不存在顶点到其自身的边，且同一条边不重复出现。 无向完全图：无向图中，任意两个顶点之间都存在边。 有向完全图：有向图中，任意两个顶点之间都存在方向互为相反的两条弧。 稀疏图：有很少条边。 稠密图：有很多条边。 权（Weight）：与图的边或弧相关的数。 网（Network）：带权的图。 子图（Subgraph）：假设G=（V,{E}）和G‘=（V’,{E’}），如果V’包含于V且E’包含于E，则称G’为G的子图。 度（Degree）：无向图中，与顶点V相关联的边的数目。有向图中，入度表示指向自己的边的数目，出度表示指向其他边的数目，该顶点的度等于入度与出度的和。 路径的长度：一条路径上边或弧的数量。连通图：图中任意两个顶点都是连通的。 1图1不是连通图，图2是连通图。 连通分量：无向图中的极大连通子图。（子图必须是连通的且含有极大顶点数）。图1有两个连通分量强连通分量：有向图中的极大强连通子图。 生成树：无向图中连通且n个顶点n-1条边叫生成树。 有向树：有向图中一顶点入度为0其余顶点入度为1。 森林：一个有向图由若干棵有向树构成生成森林。 二、图的存储结构 1.邻接矩阵：用两个数组，一个数组保存顶点集，一个数组保存边集。 图的邻接矩阵存储的结构： [objc] view plain copy define maxvex 100 typedef struct{char vexs[maxvex];int arc[maxvex][maxvex];int vertex,edges;}MGraph;无向图的创建代码： [objc] view plain copy define maxvexs 100 define infinity 65535//用65535来表示∞ typedef struct{ 123char vexs[maxvexs]; int arc[maxvexs][maxvexs]; int vertexes,edges; }mgraph; void creatgraph(mgraph *g){ 123456789101112131415int i,j,k,w; printf(&quot;输入顶点数和边数:\n&quot;); scanf(&quot;%d,%d&quot;,&amp;g-&gt;vertexes,&amp;g-&gt;edges); for(i=0;i&lt;g-&gt;vertexes;i++)//读入顶点信息，建立顶点表 scanf(&quot;%c&quot;,&amp;g-&gt;vexs[i]); for(i=0;i&lt;g-&gt;vertexes;i++) for(j=0;j&lt;g-&gt;vertexes;j++) g-&gt;arc[i][j]=infinity;//初始化邻接矩阵 for(k=0;k&lt;g-&gt;vertexes;k++)//读入edges条边，建立邻接矩阵 &#123; printf(&quot;输入边(Vi,vj)上的下标i，下标j,和权w:\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;w); g-&gt;arc[i][j]=w; g-&gt;arc[j][i]=w;//无向图，矩阵对称 &#125; } 2.邻接表：数组与链表相结合的存储方法。 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。 邻接表结点定义 [objc] view plain copytypedef struct EdgeNode{ 123int adjvex; //邻接点域，存储该顶点对应的下标 int weight; //用于存储权值，对于非网图可以不需要 struct EdgeNode *next; //链域，指向下一个邻接点 }EdgeNode;//边表结点 typedef struct VertexNode //顶点表结点{ 12char data; //顶点域，存储顶点信息 EdgeNode *firstedge; //边表头指针 }VertexNode,AdjList[MAXVEX]; typedef struct{ 12AdjList adjList; int numVertexes,numEdges;//图中当前顶点数和边数 }GraphAdjList; 三、图的遍历1.深度优先遍历（DFS）：从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。 2.广度优先遍历（BFS）：类似于树的层次遍历。 四、最小生成树 最小生成树：构造连通网的最小代价生成树。 1.普里姆（prime）： 第一种：先将一个起点加入最小生成树，之后不断寻找与最小生成树相连的边权最小的边能通向的点，并将其加入最小生成树，直至所有顶点都在最小生成树中。 第二种：1.将一个图的顶点分为两部分，一部分是最小生成树中的结点（A集合），另一部分是未处理的结点（B集合）。 2.首先选择一个结点，将这个结点加入A中，然后，对集合A中的顶点遍历，找出A中顶点关联的边权值最小的那个（设为v），将此顶点从B中删除，加入集合A中。 3.递归重复步骤2，直到B集合中的结点为空，结束此过程。 4.A集合中的结点就是由Prime算法得到的最小生成树的结点，依照步骤2的结点连接这些顶点，得到的就是这个图的最小生成树。 2.克鲁斯卡尔（kluskal）:在剩下的所有未选取的边中，找最小边，如果和已选取的边构成回路，则放弃，选取次小边。 五、最短路径 1.迪杰斯特拉算法（Dijkstra）：把图中的顶点集合V分成两组，第一组为已求出最短路径的顶点集合S（初始时S中只有源节点，以后每求得一条最短路径，就将它对应的顶点加入到集合S中，直到全部顶点都加入到S中）；第二组是未确定最短路径的顶点集合U。 算法步骤： 1234（1）初始化时，S只含有源节点；（2）从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度）；（3）以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离；（4）重复步骤（2）和（3），直到终点在S中。 2.弗洛伊德算法（Floyd）：1，从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。2，对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。]]></content>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Observer-Pattern]]></title>
    <url>%2F2018%2F03%2F18%2FObserver-Pattern%2F</url>
    <content type="text"><![CDATA[Design Pattern的出现意义概念就不说了之前文章就有. 它的意义或者说作用是: 将代码设计得更好, 比如要可以重复使用、容易看懂、代码要可靠正确等, 达到这些要求便能真正实现工程化. 总的来说就是你要有做一名代码艺术大师的理想, 才能成为一合格的工程师. 言而总之: 设计模式即为艺术, 让它美起来 观察者模式概念:一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 分析: 1). 适用一对多-&gt;所以体现了它的作用价值或者说意义 2). 主动发送自己的状态变化-&gt;能与观察者分离逻辑, 让其只需要管好自己需要做的事情即可, 懒即为创造 3). 缺点: 需要直接管理一个含所有观察者的集合, 可能会泄露UI实例 与订阅者模式的异同观察者模式的角色为观察者(observer)和主题(subject)对象，observer需要观察subject时，需先到subject里面进行注册（subject对象持有observer对象的集合句柄），然后，当subject对象的内部状态发生变化时，把这个变化通知所有的观察者。 发布-订阅模式的角色为发布者(publisher)和订阅者(subscriber)，pub和sub之间没有直接的耦合关系，pub发布一个消息事件(event)，sub订阅感兴趣的消息事件，sub也可以取消订阅。 图见这 分析:1). 都有事件接受者和发出者, 发出者作为目标主体将状态变化发出, 观察者接收到事件然后处理2). 两种模式都可以用于松散耦合，改进代码管理和潜在的复用3). 订阅模式多了一个调度中心, 它才是注册观察者的地方, 所以两者没了依赖, 正应了 中间层就能解耦合的话 UML类图的基本知识在UML类图中，常见的有以下几种关系: 泛化（Generalization）: 指的是一个类class继承另外的一个类class, 本身也可新增功能. 符号: 空心三角箭头+实线, 指向父类(寻找基类) 实现（Realization）: 指的是一个class类实现interface接口. 符号: 空心三角箭头+虚线, 指向接口(寻找接口定义) 关联（Association）: 体现的是两个类或类与接口之间语义级别的一种强依赖关系(成员变量), 关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的. 符号: 一角箭头+实线(双向时无需箭头), 指向持有者(寻找使用者) 聚合（Aggregation）: 是关联关系的一种特例，他体现的是整体与部分、拥有的关系, 此时整体与部分之间是可分离的(可分离只是一种能力, 关系强度仍然比关联强)，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享. 符号: 空心菱形+实线+一角箭头，指向持有者(寻找使用者) 组合（Composition）: 也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合. 他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束. 符号: 实心菱形+实线+一角箭头，指向持有者(寻找使用者) 依赖（Dependency）: 就是一个类A使用到了另一个类B(局部变量、方法的参数或者对静态方法的调用), 使用关系是具有偶然性的、临时性的、非常弱的. 符号: 一角箭头+虚线, 指向被使用者(寻找依赖类) (泛化 = 实现) &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖。 图见这]]></content>
      <tags>
        <tag>Java Code Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Six Object-Oriented Design Principles]]></title>
    <url>%2F2018%2F03%2F14%2FSix-Object-oriented-design-principle%2F</url>
    <content type="text"><![CDATA[一. OOP六大设计原则 单一职责原则Principle SRP: 一个类仅有一个变化因素, 否则就应将其拆分 开闭原则Principle OCP: (实现类)修改要封闭, 扩展是开放的(新建实现类) 里氏替换原则Principle LSP: 使用基类的地方要能使用子类, 反之不行(Java的继承就能实现) 依赖倒置原则Principle DIP: 高层和底层都依赖抽象, 且抽象不应该依赖细节 接口隔离原则Principle ISP: 调用端(客户端)只依赖最小的接口 迪米特原则Principle LOD: 只和直接朋友通信, 对被调用模块了解最少 六大原则作用: 降低 耦合 度, 利于开发 维护 重用, 工作 效率 高; 易读 易理解. 还有设计模式…维护性, 扩展性, 易用性, 性能, 复用 二. Design Pattern设计模式针对特定问题如何组织类、对象和接口之间的关系，对在某种环境中反复出现的问题以及解决该问题的方案的描述. 框架是骨架，设计模式就是血和肉(灵魂); 框架直接拿来用小修小改, 设计模式解决编程的具体问题，代码结构的小技巧. 1. Platform平台 类似框架但是结合了架构的考虑, 它是一种应用. 针对企业用户, 整合同类技术或服务, 同时需要考虑如何进行设计. 譬如支付平台Ping++, 客服平台Udesk 2. Software Architecture软件架构 It refers to the fundamental structures of a software system, the discipline of creating such structures, and the documentation of these structures. , 简称”架构”或者”建筑”, 是软件系统的基础结构和生成基础结构的原理以及结构的文档. 其实简而言之就是设计蓝图. 如: 分层架构(3或4层, 表现层, 业务层, 持久层, 数据库)它的责任: 确定目标系统的边界 以某个原则切分系统, 其原则应满足利于不同角色并行或者穿行工作, 并适当考虑提高效率 对切分后的部分设立沟通机制 利用沟通机制进行有效联系, 合并组装成为一个整体, 完成目标系统的所有工作 3. Framework框架 为软件程师提供的组件, 它提取特定领域的软件共性部分作为一个体系, 是一个整体或者部分系统的可重用设计, 多为半成品可以修改定制, 以实现具体功能和效果的应用系统. 如: Zxing库. 总结: 设计模式是代码级复用、框架是模块级复用、架构是系统级复用、平台是企业应用级复用 三. 基础概念:A. 模式相关Pattern: 事物的标准样式, 是一种认识论意义上的确定思维方式(即解决某一类问题的方法论). 从不断重复出现的事件中发现和抽象出的规律，是解决问题形成经验的高度归纳总结。只要是一再重复出现的事物，就可能存在某种模式。你把解决某类问题的方法总结归纳到理论高度, 那就是模式(架构采用某种方法论即是架构模式) Software Pattern: 适用于开发软件的规律或标准或经验, 包括: 架构模式(也称结构模式或体系结构模, 如MVP), 设计模式等。体系架构模式是一个通用的、可重用的解决方案，描述软件系统基本的结构化组织方案，是最高等级模式，明确了一个应用的基本结构, 用于解决在给定上下文中的软件体系结构中经常出现的问题。(体系)架构模式与(软件)设计模式类似, 但具有更广泛的范围. 10种常见的架构模式: 分层模式客户端-服务器模式主从设备模式管道-过滤器模式代理模式点对点模式事件总线模式模型-视图-控制器模式黑板模式解释器模式 架构模式分类: 混沌到结构 （层、管道和过滤器、黑板模式）分布式系统 （主要：代理模式 次要：微核模式、管道和过滤器模式）交互式系统 （MVC、PAC、MVP）适应性系统 （映像模式、微核模式） Design Pattern: 在某种环境中反复出现的问题以及解决该问题的方案的描述 B. 架构相关:1)System: 系统, 体系. 泛指部分组合而成的整体，是不同系统组成的系统, 强调部分与整体的关系 2)Architecture: 体系结构, 架构. 强调系统的组成, 包括构成部件以及部件之间的联系 3)System Architecture: 系统体系结构. 是一个综合模型，系统体系结构是由许多结构要素及各种视图(View)或观点所组成的. 所以，系统体系结构是一个综合各种观点的模型，用来完整描述整个系统。 4)Software Architecture: 软件体系结构.是具有一定形式的结构化元素，即构件的集合，包括处理构件、数据构件和连接构件。处理构件负责对数据进行加工，数据构件是被加工的信息，连接构件把体系结构的不同部分组组合连接起来。由于软件系统具有的一些共通特性，能够促进大规模软件的系统级复用。 5)System Architects: 系统架构师]]></content>
      <tags>
        <tag>Java Object-oriented</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Translation) A Small Leak Will Sink a Great Ship]]></title>
    <url>%2F2018%2F01%2F21%2FTranslation-A-Small-Leak-Will-Sink-a-Great-Ship%2F</url>
    <content type="text"><![CDATA[小泄露大翻船 Android Lollipop之前版本, 弹出dialog可能导致Android应用内存泄露 由 Pierre-Yves Ricau 原创 这篇文章开始于在我构建LeakCanary作为内部邮件专题时. 我发现了一个奇怪的内存泄露, 然后开始深入挖掘找出发生了什么事情。 艺术大师 我得到来自 LeakCanary的内存泄漏报告: 1234* GC ROOT thread com.squareup.picasso.Dispatcher.DispatcherThread.&lt;Java Local&gt;* references android.os.Message.obj* references com.example.MyActivity$MyDialogClickListener.this$0* leaks com.example.MyActivity.MainActivity instance 简而言之：Picasso 线程将一个Message实例作为一个局部变量放在堆栈上。该Message 引用了一个DialogInterface.OnClickListener，该接口本身引用了一个被销毁的Activity。局部变量通常是短暂存活的，因为它们只存在于堆栈中。 在线程上调用方法时，会分配一个堆栈帧。当方法返回时，该堆栈帧被清除，并且所有的局部变量都被垃圾收集。 如果一个局部变量导致泄漏，那么通常意味着一个线程正在循环或阻塞，同时还持有对Message实例的引用。 Dimitris和我看了Picasso 的源代码。 Dispatcher.DispatcherThread 是一个简单的HandlerThread 12345static class DispatcherThread extends HandlerThread &#123; DispatcherThread() &#123; super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); &#125;&#125; 这个线程通过一个用一种很常规的方式实现的Handler接收Message 1234567891011121314151617private static class DispatcherHandler extends Handler &#123; private final Dispatcher dispatcher; public DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123; super(looper); this.dispatcher = dispatcher; &#125; @Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; // ... handles other types of messages &#125; &#125;&#125; 这是条死路 。 Dispatcher.DispatcherHandler.handleMessage（）中没有明显的bug，它以某种方式通过局部变量保持对消息的引用。 队列提示 最终，更多的内存泄漏报告出现了。不仅仅是Picasso。 我们从各种类型的线程中得到了局部变量泄漏，并且总牵扯到一个dialog点击监听器。泄漏的线程有一个共同的特点：它们都是工作线程，通过某种阻塞队列接收然后工作。我们来看看HandlerThread是如何工作的： 12345678for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; return; &#125; msg.target.dispatchMessage(msg); msg.recycleUnchecked();&#125; 百分百确定有一个引用消息的本地变量。 但它可能存活的非常短暂, 只要一循环迭代就会被清除。我们尝试通过编写一个带有阻塞队列的裸露线程，然后只发送一条消息去重现它: 1234567891011121314151617181920212223242526static class MyMessage &#123; final String message; MyMessage(String message) &#123; this.message = message; &#125;&#125;static void startThread() &#123; final BlockingQueue&lt;MyMessage&gt; queue = new LinkedBlockingQueue&lt;&gt;(); MyMessage message = new MyMessage("Hello Leaking World"); queue.offer(message); new Thread() &#123; @Override public void run() &#123; try &#123; loop(queue); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;.start();&#125;static void loop(BlockingQueue&lt;MyMessage&gt; queue) throws InterruptedException &#123; while (true) &#123; MyMessage message = queue.take(); System.out.println("Received: " + message); &#125;&#125; 一旦消息在日志中打印, 我们希望MyMessage实例被垃圾回收. 可LeakCanary 却不赞同我的设想: 12* GC ROOT thread com.example.MyActivity$2.&lt;Java Local&gt; (named 'Thread-110')* leaks com.example.MyActivity$MyMessage instance 只要我们发送一个新的消息到队列中，之前的消息就被垃圾回收了，而这个新消息就马上泄漏。 在VM中，每个堆栈帧都有一组局部变量。垃圾收集器是保守的：如果有一个可能活着的引用，它将不会收集它。 迭代之后，局部变量不再可达，但它仍然保留对消息的引用。 只要局部变量不再可达，解释器/ JIT就该人工地清空引用，但现在它依旧保持引用存活，并假设不会造成任何危害。 为了确认这个理论，我们手动将引用置为null, 并再次打印，以防置空不起作用： 12345678static void loop(BlockingQueue&lt;MyMessage&gt; queue) throws InterruptedException &#123; while (true) &#123; MyMessage message = queue.take(); System.out.println("Received: " + message); message = null; System.out.println("Now null: " + message); &#125;&#125; 在测试上述更改时，我们看到MyMessage实例在message设置为null后立即被垃圾回收。 我们关于虚拟机VM忽略“局部**Message**变量 ”理论似乎被证实了。 由于这个泄露可以在各种线程和队列实现中重现，所以我们现在确定这是一个虚拟机的bug。 值得注意的是，我们只能在Dalvik VM上重现，而不能在ART VM或JVM上重现。 回收池里的Message我们发现一个bug，但它会造成巨大的内存泄漏吗？ 让我们再看看我们原来的泄漏： 1234* GC ROOT thread com.squareup.picasso.Dispatcher.DispatcherThread.&lt;Java Local&gt;* references android.os.Message.obj* references com.example.MyActivity$MyDialogClickListener.this$0* leaks com.example.MyActivity.MainActivity instance 在发送给Picasso dispatcher thread的消息中，我们从未将Message.obj设置为DialogInterface.OnClickListener。 它怎么会停在那里？ 而且，message被处理后，它立即被回收然后Message.obj被置为空。 只有这样，HandlerThread才会等待下一条消息，临时泄漏上一个message： 12345678for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; return; &#125; msg.target.dispatchMessage(msg); msg.recycleUnchecked();&#125; 就这一点而言，我们知道泄露的message已经被回收，因此不会保留以前的内容。 一旦回收，message回到静态池中： 12345678910111213141516171819202122void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125;** 我们泄漏一个空Message，它可能会被重复使用，并填充不同的内容。 这个Message总是以相同的方式使用：从池中脱离，并填充内容，再放到MessageQueue，然后处理，最终又回收并放回静态池中。 因此，它应该从不持续保留它的内容。 那为什么我们总是泄露DialogInterface.OnClickListener实例？我们换个方向。 Alert Dialogs我们来创建一个简单的提醒对话框： 1234567new AlertDialog.Builder(this) .setPositiveButton("Baguette", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MyActivity.this.makeBread(); &#125; &#125;) .show();** 请注意，点击监听器具有对Activity的引用。 此匿名类转换后为以下代码： 12345678910111213// First anonymous class of MyActivity.class MyActivity$0 implements DialogInterface.OnClickListener &#123; final MyActivity this$0; MyActivity$0(MyActivity this$0) &#123; this.this$0 = this$0; &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; this$0.makeBread(); &#125;&#125;new AlertDialog.Builder(this) .setPositiveButton("Baguette", new MyActivity$0(this)); .show();** AlertDialog在内部将工作委托给AlertController： 123456789101112131415161718192021222324/** * Sets a click listener or a message to be sent when the button is clicked. * You only need to pass one of &#123;@code listener&#125; or &#123;@code msg&#125;. */public void setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener, Message msg) &#123; if (msg == null &amp;&amp; listener != null) &#123; msg = mHandler.obtainMessage(whichButton, listener); &#125; switch (whichButton) &#123; case DialogInterface.BUTTON_POSITIVE: mButtonPositiveText = text; mButtonPositiveMessage = msg; break; case DialogInterface.BUTTON_NEGATIVE: mButtonNegativeText = text; mButtonNegativeMessage = msg; break; case DialogInterface.BUTTON_NEUTRAL: mButtonNeutralText = text; mButtonNeutralMessage = msg; break; &#125;&#125; 所以OnClickListener被封装在一个Message中，并设置为AlertController.mButtonPositiveMessage。 让我们来看看这个消息何时被使用： 1234567891011121314151617181920private final View.OnClickListener mButtonHandler = new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final Message m; if (v == mButtonPositive &amp;&amp; mButtonPositiveMessage != null) &#123; m = Message.obtain(mButtonPositiveMessage); &#125; else if (v == mButtonNegative &amp;&amp; mButtonNegativeMessage != null) &#123; m = Message.obtain(mButtonNegativeMessage); &#125; else if (v == mButtonNeutral &amp;&amp; mButtonNeutralMessage != null) &#123; m = Message.obtain(mButtonNeutralMessage); &#125; else &#123; m = null; &#125; if (m != null) &#123; m.sendToTarget(); &#125; // Post a message so we dismiss after the above handlers are executed. mHandler.obtainMessage(ButtonHandler.MSG_DISMISS_DIALOG, mDialogInterface) .sendToTarget(); &#125;&#125;; 注意这句: Message.obtain(mButtonPositiveMessage). 该消息被克隆，并发送其副本。 这意味着原始消息不会被发送，因此不会被回收。 所以它永远保持其内容，直到垃圾收集。 现在我们假设由于HandlerThread局部引用，副本消息对象在从循环池中复用之前的message。 直到该对话框最后被垃圾收集，所以会释放对mButtonPositiveMessage的消息引用。 但是，因为原消息对象此刻泄漏了，所以肯定它没有被回收。 同理, 内容、OnClickListener以及Activity都没有被回收。 吸口烟我们能证明我们的理论吗？ 我们需要发送一个消息给HandlerThread，让它消耗回收，并不发送任何其他消息到该线程，以便泄漏最后一条message。 然后，我们需要显示一个按钮的对话框，并希望这个对话框将从池中获得相同的message。 这很可能会发生，因为一旦循环利用，有个Message就成为池中的第一个消息。 12345678910111213141516171819HandlerThread background = new HandlerThread("BackgroundThread");background.start();Handler backgroundhandler = new Handler(background.getLooper());final DialogInterface.OnClickListener clickListener = new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MyActivity.this.makeCroissants(); &#125;&#125;;backgroundhandler.post(new Runnable() &#123; @Override public void run() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; new AlertDialog.Builder(MyActivity.this) // .setPositiveButton("Baguette", clickListener) // .show(); &#125; &#125;); &#125;&#125;); 如果我们运行上面的代码，然后旋转屏幕来销毁Activity，Activity很可能会泄漏。 LeakCanary准确地检测到泄漏： 1234* GC ROOT thread android.os.HandlerThread.&lt;Java Local&gt; (named 'BackgroundThread')* references android.os.Message.obj* references com.example.MyActivity$1.this$0 (anonymous class implements android.content.DialogInterface$OnClickListener)* leaks com.example.MyActivity instance 至此我们已经正确重现了它，让我们看看我们可以做些什么来解决了。 平台修复仅支持使用ART VM的设备，即Android 5+。再也没有bugs了！ 当然，也不会有更多的用户。 放弃修复你也可以假设这些泄漏的影响是有限的，你有更棒的事情要做，或者是去解决更简单的泄漏。 LeakCanary 默认忽略所有Message泄露。 但要注意，一个Activity 在内存中保存了整个视图层次结构，它可以保留好几M。 内部修复确保您的DialogInterface.OnClickListener实例不持有对Ativity实例的强引用，例如，在对话窗口detached后清除对监听器listener的引用。 这里是一个包装类，方便清除listener引用: 1public final class DetachableClickListener implements DialogInterface.OnClickListener &#123; 123public static DetachableClickListener wrap(DialogInterface.OnClickListener delegate) &#123; return new DetachableClickListener(delegate);&#125; 1private DialogInterface.OnClickListener delegateOrNull; 1234567891011121314151617181920 private DetachableClickListener(DialogInterface.OnClickListener delegate) &#123; this.delegateOrNull = delegate; &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; if (delegateOrNull != null) &#123; delegateOrNull.onClick(dialog, which); &#125; &#125; public void clearOnDetach(Dialog dialog) &#123; dialog.getWindow() .getDecorView() .getViewTreeObserver() .addOnWindowAttachListener(new OnWindowAttachListener() &#123; @Override public void onWindowAttached() &#123; &#125; @Override public void onWindowDetached() &#123; delegateOrNull = null; &#125; &#125;); &#125;&#125; 然后你可以包装所有的OnClickListener实例： 12345678910DetachableClickListener clickListener = wrap(new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MyActivity.this.makeCroissants(); &#125;&#125;);AlertDialog dialog = new AlertDialog.Builder(this) // .setPositiveButton("Baguette", clickListener) // .create();clickListener.clearOnDetach(dialog);dialog.show(); 管道修复定期刷新工作线程：当HandlerThread空闲时发送一条空的Message，以确保没有消息泄漏很长时间。 12345678910111213static void flushStackLocalLeaks(Looper looper) &#123; final Handler handler = new Handler(looper); handler.post(new Runnable() &#123; @Override public void run() &#123; Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; handler.sendMessageDelayed(handler.obtainMessage(), 1000); return true; &#125; &#125;); &#125; &#125;);&#125; 这对第三方库很有用，因为你无法控制开发者要用dialogs做什么。 我们在Picasso中使用上了它，在其他类型的工作线程也用了此类修复。 总结正如我们所看到的，一个微妙的和意想不到的虚拟机行为会发生一个小泄漏导致大量的内存崩溃，最终导致应用程序崩溃，出现OutOfMemoryError内存溢出。 一个小小的泄漏让一艘大船沉没了。 非常感谢Josh Humphries, Jesse Wilson, Manik Surtani, 和 Wouter Coekaerts 在我们的内部电子邮件专题中提供帮助。 译者注: 原文在这里]]></content>
      <tags>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A small leak will sink a great ship]]></title>
    <url>%2F2018%2F01%2F21%2Fa-small-leak%2F</url>
    <content type="text"><![CDATA[小泄露大翻船 Android Lollipop之前版本, 弹出dialog可能导致Android应用内存泄露 由 Pierre-Yves Ricau 原创 这篇文章开始于在我构建LeakCanary作为内部邮件专题时. 我发现了一个奇怪的内存泄露, 然后开始深入挖掘找出发生了什么事情。 艺术家 我得到来自 LeakCanary的内存泄漏报告: 1234* GC ROOT thread com.squareup.picasso.Dispatcher.DispatcherThread.&lt;Java Local&gt;* references android.os.Message.obj* references com.example.MyActivity$MyDialogClickListener.this$0* leaks com.example.MyActivity.MainActivity instance 简而言之：Picasso 线程将一个Message实例作为一个局部变量放在堆栈上。该Message 引用了一个DialogInterface.OnClickListener，该接口本身引用了一个被销毁的Activity。局部变量通常是短暂存活的，因为它们只存在于堆栈中。 在线程上调用方法时，会分配一个堆栈帧。当方法返回时，该堆栈帧被清除，并且所有的局部变量都被垃圾收集。 如果一个局部变量导致泄漏，那么通常意味着一个线程正在循环或阻塞，同时还持有对Message实例的引用。 Dimitris和我看了Picasso 的源代码。 Dispatcher.DispatcherThread 是一个简单的HandlerThread 12345static class DispatcherThread extends HandlerThread &#123; DispatcherThread() &#123; super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); &#125;&#125; 这个线程通过一个用一种很常规的方式实现的Handler接收Message 1234567891011121314151617private static class DispatcherHandler extends Handler &#123; private final Dispatcher dispatcher; public DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123; super(looper); this.dispatcher = dispatcher; &#125; @Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; // ... handles other types of messages &#125; &#125;&#125; 这是一条死路 。 Dispatcher.DispatcherHandler.handleMessage（）中没有明显的bug，它以某种方式通过局部变量保持对消息的引用。 队列建议 最终，更多的内存泄漏报告出现了。不仅仅是Picasso。 我们从各种类型的线程中得到了局部变量泄漏，并且总牵扯到一个dialog点击监听器。泄漏的线程有一个共同的特点：它们都是工作线程，通过某种阻塞队列接收然后工作。我们来看看HandlerThread是如何工作的： 12345678for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; return; &#125; msg.target.dispatchMessage(msg); msg.recycleUnchecked();&#125; 百分百有一个引用消息的本地变量。 但它应该存活的非常短暂, 只要一循环迭代就会被清除。我们尝试通过编写一个带有阻塞队列的裸露线程，然后只发送一条消息去重现它: 1234567891011121314151617181920212223242526static class MyMessage &#123; final String message; MyMessage(String message) &#123; this.message = message; &#125;&#125;static void startThread() &#123; final BlockingQueue&lt;MyMessage&gt; queue = new LinkedBlockingQueue&lt;&gt;(); MyMessage message = new MyMessage("Hello Leaking World"); queue.offer(message); new Thread() &#123; @Override public void run() &#123; try &#123; loop(queue); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;.start();&#125;static void loop(BlockingQueue&lt;MyMessage&gt; queue) throws InterruptedException &#123; while (true) &#123; MyMessage message = queue.take(); System.out.println("Received: " + message); &#125;&#125; 一旦消息在日志中打印, 我们希望MyMessage实例被垃圾回收. 可LeakCanary 却不赞同: 12* GC ROOT thread com.example.MyActivity$2.&lt;Java Local&gt; (named 'Thread-110')* leaks com.example.MyActivity$MyMessage instance 只要我们发送一个新的消息到队列中，之前的消息就被垃圾回收了，而这个新消息就马上泄漏。 在VM中，每个就不会回收它。 迭代之后，局部变量不再可达，但它仍然保留对消息的引用。 只要局部变量不再可达，解释器/ JIT就该人工地清空引用，但现在它只是保持引用存活，并假设不会造成任何危害。 为了确认这个理论，我们手动将引用置为null, 并再次打印，使null不被优化： 12345678static void loop(BlockingQueue&lt;MyMessage&gt; queue) throws InterruptedException &#123; while (true) &#123; MyMessage message = queue.take(); System.out.println("Received: " + message); message = null; System.out.println("Now null: " + message); &#125;&#125; 在测试上述更改时，我们看到MyMessage实例在message设置为null后立即被垃圾回收。 我们关于虚拟机VM忽略“局部**Message**变量 ”理论似乎被证实了。 由于这个泄露可以在各种线程和队列实现中重现，所以我们现在确定这是一个虚拟机的bug。 最重要的是，我们只能在Dalvik VM上重现，而不能在ART VM或JVM上重现。 回收瓶里的Message我们发现一个bug，但它会造成巨大的内存泄漏吗？ 让我们再看看我们原来的泄漏： 1234* GC ROOT thread com.squareup.picasso.Dispatcher.DispatcherThread.&lt;Java Local&gt;* references android.os.Message.obj* references com.example.MyActivity$MyDialogClickListener.this$0* leaks com.example.MyActivity.MainActivity instance 在发送给Picasso dispatcher thread的消息中，我们从未将Message.obj设置为DialogInterface.OnClickListener。 它怎么会停在那里？ 而且，message被处理后，它立即被回收然后Message.obj被置为空。 只有这样，HandlerThread才会等待下一条消息，临时泄漏上一个message： 12345678for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; return; &#125; msg.target.dispatchMessage(msg); msg.recycleUnchecked();&#125; 就这一点而言，我们知道泄露的message已经被回收，因此不会保留以前的内容。 一旦回收，message回到静态池中： 12345678910111213141516171819202122void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125;** 我们泄漏一个空Message，它可能会被重复使用，并填充不同的内容。 这个Message总是以相同的方式使用：从池中脱离，并填充内容，再放到MessageQueue，然后处理，最终又回收并放回静态池中。 因此，它应该从不持续保留它的内容。 那为什么我们总是泄露DialogInterface.OnClickListener实例？ Alert Dialogs我们来创建一个简单的提醒对话框： 1234567new AlertDialog.Builder(this) .setPositiveButton("Baguette", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MyActivity.this.makeBread(); &#125; &#125;) .show();** 请注意，点击监听器具有对Activity的引用。 此匿名类转换后为以下代码： 12345678910111213// First anonymous class of MyActivity.class MyActivity$0 implements DialogInterface.OnClickListener &#123; final MyActivity this$0; MyActivity$0(MyActivity this$0) &#123; this.this$0 = this$0; &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; this$0.makeBread(); &#125;&#125;new AlertDialog.Builder(this) .setPositiveButton("Baguette", new MyActivity$0(this)); .show();** AlertDialog在内部将工作委托给AlertController： 123456789101112131415161718192021222324/** * Sets a click listener or a message to be sent when the button is clicked. * You only need to pass one of &#123;@code listener&#125; or &#123;@code msg&#125;. */public void setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener, Message msg) &#123; if (msg == null &amp;&amp; listener != null) &#123; msg = mHandler.obtainMessage(whichButton, listener); &#125; switch (whichButton) &#123; case DialogInterface.BUTTON_POSITIVE: mButtonPositiveText = text; mButtonPositiveMessage = msg; break; case DialogInterface.BUTTON_NEGATIVE: mButtonNegativeText = text; mButtonNegativeMessage = msg; break; case DialogInterface.BUTTON_NEUTRAL: mButtonNeutralText = text; mButtonNeutralMessage = msg; break; &#125;&#125; 所以OnClickListener被封装在一个Message中，并设置为AlertController.mButtonPositiveMessage。 让我们来看看这个消息何时被使用： 1234567891011121314151617181920private final View.OnClickListener mButtonHandler = new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final Message m; if (v == mButtonPositive &amp;&amp; mButtonPositiveMessage != null) &#123; m = Message.obtain(mButtonPositiveMessage); &#125; else if (v == mButtonNegative &amp;&amp; mButtonNegativeMessage != null) &#123; m = Message.obtain(mButtonNegativeMessage); &#125; else if (v == mButtonNeutral &amp;&amp; mButtonNeutralMessage != null) &#123; m = Message.obtain(mButtonNeutralMessage); &#125; else &#123; m = null; &#125; if (m != null) &#123; m.sendToTarget(); &#125; // Post a message so we dismiss after the above handlers are executed. mHandler.obtainMessage(ButtonHandler.MSG_DISMISS_DIALOG, mDialogInterface) .sendToTarget(); &#125;&#125;; 注意这句: Message.obtain(mButtonPositiveMessage). 该消息被克隆，并发送其副本。 这意味着原始消息不会被发送，因此不会被回收。 所以它永远保持其内容，直到垃圾收集。 现在让我们假设由于HandlerThread局部引用，这个消息在从循环池中获取之前已经泄漏的message。 该对话框最终被垃圾收集，并释放对mButtonPositiveMessage的消息引用。 但是，因为该消息现在是泄漏的，所以可以肯定它没有被垃圾回收。 同理, 内容、OnClickListener以及Activity都没有被回收。 吸烟枪我们能证明我们的理论吗？ 我们需要发送一个消息给HandlerThread，让它消耗回收，并不发送任何其他消息到该线程，以便泄漏最后一条message。 然后，我们需要显示一个按钮的对话框，并希望这个对话框将从池中获得相同的message。 这很可能会发生，因为一旦循环利用，有个Message就成为池中的第一个消息。 12345678910111213141516171819HandlerThread background = new HandlerThread("BackgroundThread");background.start();Handler backgroundhandler = new Handler(background.getLooper());final DialogInterface.OnClickListener clickListener = new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MyActivity.this.makeCroissants(); &#125;&#125;;backgroundhandler.post(new Runnable() &#123; @Override public void run() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; new AlertDialog.Builder(MyActivity.this) // .setPositiveButton("Baguette", clickListener) // .show(); &#125; &#125;); &#125;&#125;); 如果我们运行上面的代码，然后旋转屏幕来销毁Activity，Activity很可能会泄漏。 LeakCanary准确地检测到泄漏： 1234* GC ROOT thread android.os.HandlerThread.&lt;Java Local&gt; (named 'BackgroundThread')* references android.os.Message.obj* references com.example.MyActivity$1.this$0 (anonymous class implements android.content.DialogInterface$OnClickListener)* leaks com.example.MyActivity instance 至此我们已经正确重现了它，让我们看看我们可以做些什么来解决了。 安装级修复仅支持使用ART VM的设备，即Android 5+。再也没有bugs了！ 当然，也不会有更多的用户。 放弃修复你也可以假设这些泄漏的影响是有限的，你有更棒的事情要做，或者是去解决更简单的泄漏。 LeakCanary 默认忽略所有Message泄露。 但要注意，一个Activity 在内存中保存了整个视图层次结构，它可以保留好几M。 App级修复确保您的DialogInterface.OnClickListener实例不持有对Ativity实例的强引用，例如，在对话窗口detached后清除对监听器listener的引用。 这里是一个包装类，方便清除listener引用: 1public final class DetachableClickListener implements DialogInterface.OnClickListener &#123; 123public static DetachableClickListener wrap(DialogInterface.OnClickListener delegate) &#123; return new DetachableClickListener(delegate);&#125; 1private DialogInterface.OnClickListener delegateOrNull; 1234567891011121314151617181920 private DetachableClickListener(DialogInterface.OnClickListener delegate) &#123; this.delegateOrNull = delegate; &#125; @Override public void onClick(DialogInterface dialog, int which) &#123; if (delegateOrNull != null) &#123; delegateOrNull.onClick(dialog, which); &#125; &#125; public void clearOnDetach(Dialog dialog) &#123; dialog.getWindow() .getDecorView() .getViewTreeObserver() .addOnWindowAttachListener(new OnWindowAttachListener() &#123; @Override public void onWindowAttached() &#123; &#125; @Override public void onWindowDetached() &#123; delegateOrNull = null; &#125; &#125;); &#125;&#125; 然后你可以包装所有的OnClickListener实例： 12345678910DetachableClickListener clickListener = wrap(new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MyActivity.this.makeCroissants(); &#125;&#125;);AlertDialog dialog = new AlertDialog.Builder(this) // .setPositiveButton("Baguette", clickListener) // .create();clickListener.clearOnDetach(dialog);dialog.show(); 水管工级修复定期刷新工作线程：当HandlerThread空闲时发送一条空的Message，以确保没有消息泄漏很长时间。 12345678910111213static void flushStackLocalLeaks(Looper looper) &#123; final Handler handler = new Handler(looper); handler.post(new Runnable() &#123; @Override public void run() &#123; Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; handler.sendMessageDelayed(handler.obtainMessage(), 1000); return true; &#125; &#125;); &#125; &#125;);&#125; 这对第三方库很有用，因为你无法控制开发者要用dialogs做什么。 我们在Picasso中使用上了它，在其他类型的工作线程也用了此类修复。 总结正如我们所看到的，一个微妙的和意想不到的虚拟机行为会发生一个小泄漏导致大量的内存崩溃，最终导致应用程序崩溃，出现OutOfMemoryError内存溢出。 一个小小的泄漏让一艘大船沉没了。 非常感谢Josh Humphries, Jesse Wilson, Manik Surtani, 和 Wouter Coekaerts 在我们的内部电子邮件专题中提供帮助。 译者注: 原文在这里, 上一篇Fragment Transactions &amp; Activity State Loss的原文在这]]></content>
      <tags>
        <tag>Code Repair</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Translation) Fragment Transactions & Activity State Loss]]></title>
    <url>%2F2018%2F01%2F16%2FTranslation-Fragment-Transactions-Activity-State-Loss%2F</url>
    <content type="text"><![CDATA[以下堆栈追踪和异常信息自从Honeycomb’s初期版本以来就困扰着StackOverflow: 12345java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341) at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352) at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595) at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574) 这篇文章将会解释原因以及何时抛出异常, 然后总结一些确保你的应用程序不再奔溃的建议. 为什么抛出异常?这个异常被抛出是因为你尝试在Activity的状态被save之后, commit一个FragmentTransaction, 才导致一个被称为Activity状态丢失的现象.不管怎样, 在我们详细讨论这个实际的含义之前, 让我们首先来看看在调用onSaveInstanceState()时在背后发生了什么. 正如我在上一篇关于 Binders &amp; Death Recipients的文章所讨论的那样, Android应用在Android runtime环境中几乎无法控制自己的命运(译者注: Android应用开发似乎这是通病, 但收紧系统利于降低开发成本和开发者快速面向功能实现而非分心去应付庞杂的事情). Android系统有权在任何时候终结进程以释放内存,而后台Activity可能因此而几乎没任何警告而被杀死. 为了应对这种对用户来讲是隐藏的, 有时不稳定的系统行为, Framework层在Activity变得易受破坏前, 会给每个Activity一个机会调用它的onSaveInstanceState()方法去保存它的状态. 当保存的状态稍后恢复时, 无论Activity是否被系统杀死,用户会感觉在前台Activity和后台Activity之间是无缝切换的,当framework层调onSaveInstanceState()时, 它传递一个含Bundle对象的方法来使Activity保存它的状态, 包括内部Dialog, Fragment和View的状态.当方法返回时, 系统通过Binder接口包装Bundle对象到System Server进程, 在那里会被安全地存放. 在系统稍后决定重新创建Activity时, 会发送那个相同的Bundle对象给App, 以便它用来恢复Activity之前的状态. 那么为什么会抛出异常呢? 好吧, 问题源于这样一个事实, 即这些Bundle对象都代表了onSaveInstanceState()被调用时Activity的一张快照, 仅此而已.这意味着当你在调用onSaveInstanceState()之后所有的FragmentTransaction# commit(), transaction事务操作没有被记录因此它从来没有被存储为Activity状态的一部分.从用户的角度看, transaction操作将丢失, 导致意外的UI状态丢失. 为了用户体验, Android系统要不惜一切代价避免状态丢失防止界面错误显示。即在任何时候，fragment事务操作如果会将引起UI意外丢失时就会简单抛出一个IllegalStateException异常，防止不可信或者不一致的体验. 什么时候抛出异常?如果您之前遇到过这个异常，您可能已经注意到，在不同的平台版本中，引发的时机略有不同。例如，您可能发现较旧的设备倾向于少抛出异常，或者使用第三方支持库时应用程序比使用官方框架类时更容易崩溃。这些微小的不一致导致许多人认为支持库是错误的，不能被信任。 但是，这些设想推测通常是错误的。 之所以存在这些微小的不一致之处，是因为对Honeycomb中的Activity生命周期的重大改变。在Honeycomb之前，活动在被暂停之前不会被视为killable，这意味着onSaveInstanceState（）在onPause（）之前被立即调用。然而，从Honeycomb开始，活动只有在停止(指stop, 不是指暂停pause)之后才被认为是可杀死的，这意味着onSaveInstanceState（）现在将在onStop（）之前而不是在onPause（）之前被调用。这些差异总结在下表中： pre-Honeycomb post-Honeycomb Activities can be killed before onPause()? NO NO Activities can be killed before onStop()? YES NO onSaveInstanceState(Bundle) is guaranteed to be called before… onPause() onStop() 由于对Activity生命周期所做的轻微更改，支持库有时需要根据平台版本来改变其行为。例如，在Honeycomb 设备及其以上版本中，每次在onSaveInstanceState（）之后调用commit（）警告开发者状态丢失已经发生。然而，每次发生这种情况时都抛出一个异常，对于Honeycomb 之前版本设备来说，它们的限制性太强了，因为它们的onSaveInstanceState（）方法在Activity的生命周期中调用的时间要早得多，因此更容易受到意外的状态丢失的威胁。Android团队不得不做出妥协：为了更好地与旧版本的平台进行交互，较旧的设备必须忍受onPause（）和onStop（）之间可能导致的意外状态丢失。下表总结了两种平台上支持库的行为： pre-Honeycomb post-Honeycomb commit() before onPause() OK OK commit() between onPause() and onStop() STATE LOSS OK commit() after onStop() EXCEPTION EXCEPTION 怎么避免这个异常?一旦你明白了实际发生的事情，避免活动状态的丢失就变得容易了很多。如果你已经在这篇文章中读了这么多，希望你能更好地理解支持库的工作原理，以及为什么避免应用程序丢失状态是非常重要的。如果你找到这篇文章是为了寻找一个快速修复，那么当你在你的应用程序中使用FragmentTransactions的时候，记注下面的一些建议： 在Activity生命周期方法中提交事务时要小心。 大多数应用程序只会在第一次调用onCreate（）时和/或响应用户输入时才提交事务，因此不会面临任何问题。但是，随着事务开始冒险进入其他Activity生命周期方法，如onActivityResult（），onStart（）和onResume（），事情会变得有点棘手。例如，您不应该在FragmentActivity＃onResume（）方法内提交事务，因为在某些情况下，可以在恢复活动状态之前调用该方法（有关详细信息，请参阅文档) ）。如果您的应用程序需要在除onCreate（）之外的Activity生命周期方法中提交事务，则在FragmentActivity＃onResumeFragments（）或Activity＃onPostResume（）中执行。这两种方法保证在Activity恢复到原来的状态之后被调用，从而避免了状态一起丢失的可能性。 （作为如何做到这一点的一个例子，请查看我对这个StackOverflow question 的回答，了解如何提交FragmentTransactions以响应对Activity＃onActivityResult（）方法的调用）。 避免在异步回调方法中执行事务。 这包括常用的方法，如AsyncTask＃onPostExecute（）和LoaderManager.LoaderCallbacks＃onLoadFinished（）。 在这些方法中执行事务的问题是，在调用它们时，他们不了解Activity生命周期的当前状态。 例如，考虑以下一系列事件： 一个活动执行一个AsyncTask。 用户按下“Home”键，导致活动的onSaveInstanceState（）和onStop（）方法被调用。 AsyncTask完成并调用onPostExecute（），但不知道Activity已经停止。 FragmentTransaction在onPostExecute（）方法内被提交，导致异常被抛出。 通常，在这些情况下避免异常的最好方法是简单地避免在异步回调方法中一起提交事务。 Google工程师似乎也同意这一观点。根据Android开发者小组的这篇文章，Android团队认为，从异步回调方法中提交FragmentTransaction导致的用户界面的主要变化可能会对用户体验造成不利影响。如果您的应用程序需要在这些回调方法中执行事务，并且没有简单的方法来保证在onSaveInstanceState（）之后不会调用回调，你可能不得不求助于使用commitAllowingStateLoss（）并处理可能发生的状态丢失。 （另请参阅这两个StackOverflow帖子，了解更多建议，这里 and 这里）。 commitAllowingStateLoss（）的使用只作为最后的手段。 调用commit（）和commitAllowingStateLoss（）之间的唯一区别是，如果发生状态丢失，后者不会抛出异常。通常情况下你不会想使用这种方法，因为这意味着有可能出现状态损失。 当然，更好的解决方案是编程确保在保存Activity状态之前调用commit（），因为这会带来更好的用户体验。除非无法避免状态丢失的可能性，否则不应使用commitAllowingStateLoss（）。 希望这些建议能帮助您解决过去遇到此异常的任何问题。 如果您仍然遇到麻烦，请在StackOverflow发布问题，并在下面的评论中发布链接，我可以看看。:) 一如既往，感谢您的阅读, 如果您有任何问题留下评论。 如果您觉得很棒的话，请不要忘记+1这个博客，并在Google+上分享这篇文章！ 译者注: 此文是翻译的这篇文, 可以说是最先总结Fragment事务操作异常的大神, 国内也很多同行翻译, 但是大都是机翻有错误我很强迫症. 故本文借助机翻并校正了两三个小时(笑哭..英文太烂), 达到了我满意的程度. 如果你看完了文章还是不懂怎么操作, 我这里提示下, 主要是考虑Activity生命周期!!! 所以你的事务操作必须处于安全状态, 然后再去操作. 如果还是不知代码如何写, email联系我siesielee@gmail.com 译者注: 原文在这里]]></content>
      <tags>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment Transactions & Activity State Loss(译文)]]></title>
    <url>%2F2018%2F01%2F16%2Fstateless%2F</url>
    <content type="text"><![CDATA[以下堆栈追踪和异常信息自从Honeycomb’s初期版本以来就困扰着StackOverflow: 12345java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341) at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352) at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595) at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574) 这篇文章将会解释为什么以及何时抛出异常, 然后总结一些建议有助于确保你的应用程序不再奔溃. 为什么抛出异常?这个异常被抛出是因为你尝试在Activity的状态被save之后, commit一个FragmentTransaction, 才导致一个被称为Activity状态丢失的现象.不管怎样, 在我们详细讨论这个实际的含义之前, 让我们首先来看看在调用onSaveInstanceState()时在背后发生了什么. 正如我在上一篇关于 Binders &amp; Death Recipients的文章所讨论的那样, Android应用在Android runtime环境中几乎无法控制自己的命运(译者注: Android应用开发似乎这是通病, 但收紧系统利于降低开发成本和开发者快速面向功能实现而非分心去应付庞杂的事情). Android系统有权在任何时候终结进程以释放内存,而后台Activity可能因此而几乎没任何警告而被杀死. 为了确保这种对用户来讲是隐藏的, 有时不稳定的行为,Framework层在Activity变得易受破坏前, 会给每个Activity一个机会调用它的onSaveInstanceState()方法去保存它的状态. 当保存的状态稍后恢复时, 无论Activity是否被系统杀死,用户会感觉在前台Activity和后台Activity之间是无缝切换的,当framework层调onSaveInstanceState()时, 它传递一个含Bundle对象的方法来使Activity保存它的状态, 记录内部Dialog, Fragment和View的状态.当方法返回时, 系统通过Binder接口包装Bundle对象到System Server进程, 在那里被安全地存放.在系统稍后决定重新创建Activity时, 会发送那个相同的Bundle对象到应用程序, 以便它用来恢复Activity过去的状态. 那么为什么会抛出异常呢? 好吧, 问题源于这样一个事实, 即这些Bundle对象都代表了onSaveInstanceState()被调用时Activity的一张快照, 仅此而已.这意味着当你在调用onSaveInstanceState()之后所有的FragmentTransaction# commit(), transaction事务操作没有记住因此它从来没有被记录为Activity状态的一部分.从用户的角度看, transaction操作将丢失, 导致意外的UI状态丢失. 为了用户体验, Android不惜一切代价避免状态丢失, 即任何时候要发生意外UI丢失时就会简单抛出一个IllegalStateException异常. 什么时候抛出异常?如果您之前遇到过这个异常，您可能已经注意到，在不同的平台版本中，引发的时机略有不同。例如，您可能发现较旧的设备倾向于少抛出异常，或者使用第三方支持库时应用程序比使用官方框架类时更容易崩溃。这些微小的不一致导致许多人认为支持库是错误的，不能被信任。 但是，这些假设通常是不正确的。 之所以存在这些微小的不一致之处，是因为对Honeycomb中的Activity生命周期的重大改变。在Honeycomb之前，活动在被暂停之前不会被视为killable，这意味着onSaveInstanceState（）在onPause（）之前被立即调用。然而，从Honeycomb开始，活动只有在停止(指stop, 不是指暂停pause)之后才被认为是可杀死的，这意味着onSaveInstanceState（）现在将在onStop（）之前而不是在onPause（）之前被调用。这些差异总结在下表中： pre-Honeycomb post-Honeycomb Activities can be killed before onPause()? NO NO Activities can be killed before onStop()? YES NO onSaveInstanceState(Bundle) is guaranteed to be called before… onPause() onStop() 由于对Activity生命周期所做的轻微更改，支持库有时需要根据平台版本来改变其行为。例如，在Honeycomb 设备及其以上版本中，每次在onSaveInstanceState（）之后调用commit（）警告开发者状态丢失已经发生。然而，每次发生这种情况时都抛出一个异常，对于Honeycomb 之前版本设备来说，它们的限制性太强了，因为它们的onSaveInstanceState（）方法在Activity的生命周期中调用的时间要早得多，因此更容易受到意外的状态丢失的威胁。Android团队不得不做出妥协：为了更好地与旧版本的平台进行交互，较旧的设备必须忍受onPause（）和onStop（）之间可能导致的意外状态丢失。下表总结了两种平台上支持库的行为： pre-Honeycomb post-Honeycomb commit() before onPause() OK OK commit() between onPause() and onStop() STATE LOSS OK commit() after onStop() EXCEPTION EXCEPTION 怎么避免这个异常?一旦你明白了实际发生的事情，避免活动状态的丢失就变得容易了很多。如果你已经在这篇文章中读了这么多，希望你能更好地理解支持库的工作原理，以及为什么避免应用程序丢失状态是非常重要的。如果你找到这篇文章是为了寻找一个快速修复，那么当你在你的应用程序中使用FragmentTransactions的时候，记注下面的一些建议： 在Activity生命周期方法中提交事务时要小心。 大多数应用程序只会在第一次调用onCreate（）时和/或响应用户输入时才提交事务，因此不会面临任何问题。但是，随着事务开始冒险进入其他Activity生命周期方法，如onActivityResult（），onStart（）和onResume（），事情会变得有点棘手。例如，您不应该在FragmentActivity＃onResume（）方法内提交事务，因为在某些情况下，可以在恢复活动状态之前调用该方法（有关详细信息，请参阅文档) ）。如果您的应用程序需要在除onCreate（）之外的Activity生命周期方法中提交事务，则在FragmentActivity＃onResumeFragments（）或Activity＃onPostResume（）中执行。这两种方法保证在Activity恢复到原来的状态之后被调用，从而避免了状态一起丢失的可能性。 （作为如何做到这一点的一个例子，请查看我对这个StackOverflow question 的回答，了解如何提交FragmentTransactions以响应对Activity＃onActivityResult（）方法的调用）。 避免在异步回调方法中执行事务。 这包括常用的方法，如AsyncTask＃onPostExecute（）和LoaderManager.LoaderCallbacks＃onLoadFinished（）。 在这些方法中执行事务的问题是，在调用它们时，他们不了解Activity生命周期的当前状态。 例如，考虑以下一系列事件： 一个活动执行一个AsyncTask。 用户按下“Home”键，导致活动的onSaveInstanceState（）和onStop（）方法被调用。 AsyncTask完成并调用onPostExecute（），但不知道Activity已经停止。 FragmentTransaction在onPostExecute（）方法内被提交，导致异常被抛出。 通常，在这些情况下避免异常的最好方法是简单地避免在异步回调方法中一起提交事务。 Google工程师似乎也同意这一观点。根据Android开发者小组的这篇文章，Android团队认为，从异步回调方法中提交FragmentTransaction导致的用户界面的主要变化可能会对用户体验造成不利影响。如果您的应用程序需要在这些回调方法中执行事务，并且没有简单的方法来保证在onSaveInstanceState（）之后不会调用回调，你可能不得不求助于使用commitAllowingStateLoss（）并处理可能发生的状态丢失。 （另请参阅这两个StackOverflow帖子，了解更多提示，这里 and 这里）。 commitAllowingStateLoss（）的使用只作为最后的手段。 调用commit（）和commitAllowingStateLoss（）之间的唯一区别是，如果发生状态丢失，后者不会抛出异常。 通常情况下你不会想使用这种方法，因为这意味着有可能出现状态损失。 当然，更好的解决方案是编程确保在保存Activity状态之前调用commit（），因为这会带来更好的用户体验。除非无法避免状态丢失的可能性，否则不应使用commitAllowingStateLoss（）。 希望这些建议能帮助您解决过去遇到此异常的任何问题。 如果您仍然遇到麻烦，请在StackOverflow发布问题，并在下面的评论中发布链接，我可以看看。:) 一如既往，感谢您的阅读, 如果您有任何问题留下评论。 如果您觉得很棒的话，请不要忘记+1这个博客，并在Google+上分享这篇文章！ 译者注: 此文是翻译的这篇文, 可以说是最先总结Fragment事务操作异常的大神, 国内也很多同行翻译, 但是大都是机翻有错误我很强迫症. 故本文借助机翻并校正了两三个小时(笑哭..英文太烂), 达到了我满意的程度. 如果你看完了文章还是不懂怎么操作, 我这里提示下, 主要是考虑Activity生命周期!!! 所以你的事务操作必须处于安全状态, 然后再去操作. 如果还是不知代码如何写, email联系我siesielee@gmail.com]]></content>
      <tags>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Animation]]></title>
    <url>%2F2017%2F12%2F23%2FAndroid-Anims%2F</url>
    <content type="text"><![CDATA[Android动画共有3大类 逐帧动画, 简称”帧动画”, 英文名: Frame Animation or Drawable Animation 补间动画, 又称”视图动画”, 英文名: Tween Animation or View Animation 属性动画, 英文名: Property Animation 区别 API 3.0之后才新加入了Property动画作为补充凡是前两种动画可以实现的效果, 属性动画一定可以实现其效果如果你想在API &lt; 3.0的机器上使用同样效果, 可使用NineOldAndroids动画库 逐帧动画最简单 一帧一帧的, 可以使用XML文件把资源组合起来 补间动画最常见 补间补间, 就是把起止帧之间的帧画出来, 改变View的透明度, 位置, 大小, 角度. 它结束后看到的位置不是真实坐标的改变, 只是绘制位置的改变. 属性动画最强大 会改变View的真实属性(坐标), 父类为系统抽象类Animator(有500多行)基本不直接使用, 最常用的是子类ValueAnimator和ObjectAnimator. 区别： （1）属性动画比视图动画更强大，不但可以实现缩放、平移等操作，还可以自己定义动画效果，监听动画的过程，在动画过程中或完成后做响应的动作。 （2）属性动画不但可以作用于View，还能作用于Object。 （3）属性动画利用属性的改变实现动画，而视图动画仅仅改变了view的大小位置，但view真正的属性没有改变。 注：关于真实属性，比如视图动画作用平移之后点击它会无效，因为它的坐标并未真正改变需要点击到原来位置才能生效，而这个问题对于属性动画是不存在的。 使用1. 逐帧动画特点:细腻灵活 资源制作量大 图片文件多 使用步骤: 添加帧: XML定义资源文件, 或者Java代码创建 引用支持类: AnimationDrawable代码: XML方式 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false" &gt; &lt;!-- 定义一个动画帧，Drawable为img0，持续时间50毫秒 --&gt; &lt;item android:drawable="@drawable/img0" android:duration="50" /&gt; &lt;!-- 定义一个动画帧，Drawable为img1，持续时间100毫秒 --&gt; &lt;item android:drawable="@drawable/img1" android:duration="100" /&gt; &lt;/animation-list&gt;//然后加载XMLframeAnim =(AnimationDrawable)getResources().getDrawable(id);view.setBackgroundDrawable(frameAnim);frameAnim.start();frameAnim.stop(); Java代码方式 123456frameAnim =new AnimationDrawable();frameAnim.addFrame(getResources().getDrawable(R.drawable.img0), 50);frameAnim.addFrame(getResources().getDrawable(R.drawable.img1), 100);frameAnim.setOneShot(false);view.setBackgroundDrawable(frameAnim);frameAnim.start();frameAnim.stop(); 2. 补间动画原理:给出两个关键帧, 通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。 方式实现类: AlphaAnimation：透明度（alpha）渐变效果，对应标签。 TranslateAnimation：位移渐变，需要指定移动点的开始和结束坐标，对应标签。 ScaleAnimation：缩放渐变，可以指定缩放的参考点，对应标签。 RotateAnimation：旋转渐变，可以指定旋转的参考点，对应标签。 AnimationSet：组合渐变，支持组合多种渐变效果，对应标签 特点:过渡自然 实现简单快速 使用步骤: 设置动画形式: 如渐变 设定起止状态: 如起始1.0f和结束0.1f 代码: XML方式XML文件的根元素可以为, , , ,, (表示以上几个动画的集合, set可以嵌套). 默认情况下, 所有动画是同时进行的, 可以通过startOffset属性设置各个动画的开始偏移（开始时间）来达到动画顺序播放的效果. 12345&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:fromAlpha="1.0" android:toAlpha="0.1" android:duration="2000"/&gt; Java代码方式 1234567Animation anim = new AlphaAnimation(1.0f,0.1f);//设置持续时间anim.setDuration(2000);//清除原有的动画，避免多次点击出现重复的效果view.clearAnimation();//开始执行动画view.startAnimation(anim); 3. 属性动画特点:实现费脑 属性接口更多 (如改变view的背景颜色属性) 使用步骤: 直接new出ValueAnimator或者子类ObjectAnimator 设置动画到View 代码: XML方式: 1234567891011121314151617&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:ordering="together"&gt;&lt;objectAnimator android:valueType="floatType" android:propertyName="scaleX" android:valueFrom="1" android:valueTo="2"/&gt;&lt;objectAnimator android:propertyName="translationX" android:valueType="floatType" android:valueFrom="0" android:valueTo="200"/&gt;&lt;/set&gt;Animator animator= AnimatorInflater.loadAnimator(this,R.animator.animator);animator.setTarget(imageView);animator.start(); 代码方式: 支持rotation, alpha, translationX, translationY, scaleX, scaleY, 以及使用AnimatorSet组合前者多种基础动画方式123ObjectAnimator animator = ObjectAnimator.ofFloat(imageView, "translationX", 0f, -300f, 0f);animator.setDuration(2000);animator.start(); AnimationSet提供了一个把多个动画组合成一个组合的机制，并可设置组中动画的时序关系，如同时播放，顺序播放等。123456AnimatorSet bouncer = new AnimatorSet(); bouncer.play(anim1).before(anim2); bouncer.play(anim2).with(anim3); bouncer.play(anim2).with(anim4) bouncer.play(anim5).after(amin2); animatorSet.start(); 子类源码剖析: ObjectAnimator继承自ValueAnimatorValueAnimator 包含动画的开始值，结束值，持续时间等属性 内部流程: 计算属性值时间因子(input) = 动画已进行的时间跟动画总时间(duration)的比计算(0~1)—TimeInterpolator插值因子(fraction,表示动画的完成度) = TimeInterpolator通过开始值,结束值,时间因子计算出—TimeInterpolator公式为: fraction = (Math.cos((input + 1) Math.PI) / 2.0f) + 0.5f;属性值 = TypeAnimator通过插值因子计算出 = {开始值,结束值,差值}—TypeAnimator根据TypeEvaluator的函数evaluate():public Float evaluate(float fraction, Number startValue, Number endValue) {float startFloat = startValue.floatValue();return startFloat + fraction (endValue.floatValue() - startFloat);} 根据属性值执行相应的动作, 如改变对象的某一属性。需要实现ValueAnimator.onUpdateListener接 口，这个接口只有一个函数onAnimationUpdate()，在这个函数中会传入ValueAnimator对象做为参数，通过这个 ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);animation.setDuration(1000);animation.addUpdateListener( AnimatorUpdateListener() {@OverrideonAnimationUpdate(ValueAnimator animation) {Log.i(“update”, ((Float) animation.getAnimatedValue()).toString());}});animation.setInterpolator( CycleInterpolator(3));animation.start(); ObjectAnimator 属性动画一般使用这个类, 但需满足以下条件, 否则就选用ValueAnimator 这也是两者的区别: 对象(View类等)应该有一个setter函数：set（驼峰命名法） 如上面的例子中，像ofFloat之类的工场方法，第一个参数为对象名，第二个为属性名，后面的参数为可变参数，如果values…参数只设置了一个值的话，那么会假定为目的值，属性值的变化范围为当前值到目的值，为了获得当前值，该对象要有相应属性的getter方法：get（驼峰命名法） 如果有getter方法，其应返回值类型应与相应的setter方法的参数类型一致。 内部流程:同ValueAnimator. 根据应用动画的对象或属性的不同, 可能需要在onAnimationUpdate函数中调用invalidate()函数刷新视图。 说明：请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些“需要重绘的” 视图，即谁(View的话，只绘制该View ；ViewGroup，则绘制整个ViewGroup)请求invalidate()方法，就绘制该视图。 属性动画扩展之LayoutTransition: 容器布局动画就是当一个布局容器中的view方式改变时所产生的动画，比如：但一个相对布局中新增加一个view时或者删除一个view时(或者visible改变时)，那么就可以通过一个动画来进行表现。 5种状态变化: APPEARING: 动画所运行的项目出现在这个容器中时，即：view显示时的动画 CHANGE_APPEARING: 由于在这个容器总新增加了一个view，而导致原来的view位置发生改变所以会触发这个动画。 DISAPPEARING: view在这个容器中消失时触发的动画 CHANGE_APPEARING：其他视图的出现导致某个视图改变。 CHANGE_DISAPPEARING：其他视图的消失导致某个视图改变。 使用步骤： 创建LayoutTransition对象mTransitioner 创建动画 在xml文件中将相应布局的属性Android:animateLayoutChanges=”true”设置为true 将动画通过mTransitioner的setAnimator方法设置给mTransitioner 通过布局控件的setLayoutTransition方法将mTransitioner设置进去 代码123456789101112131415161718192021mButtonAddBtn = (Button) findViewById(R.id.buttonLayoutAnmation); mLayout = (LinearLayout) findViewById(R.id.layoutanmation); LayoutTransition transition = new LayoutTransition();//创建LayoutTransition对象 transition.getDuration(2000); transition.setAnimator(LayoutTransition.APPEARING, AnimatorInflater.loadAnimator(getApplicationContext(), R.animator.animator));//创建动画 transition.setAnimator(LayoutTransition.CHANGE_APPEARING, null); transition.setAnimator(LayoutTransition.DISAPPEARING, null); transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,null); mLayout.setLayoutTransition(transition);//方法将mTransitioner设置给布局 mButtonAddBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; count++; Button btn = new Button(ActivityLayoutAnimations.this);//1.建立button对象 //2.设置LayoutParams，宽和高 ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btn.setLayoutParams(params);//3.将宽高加到button上 btn.setText("按钮" + count); mLayout.addView(btn);//4.将button加到布局中 &#125; &#125;); 后记 高级用法:http://blog.csdn.net/jdsjlzx/article/details/45558901属性动画的高级用法中最有技术含量的也就是如何编写出一个合适的TypeEvaluator View绘制流程:onMeasure()-&gt;onLayout()-&gt;onDraw()即是绘制: 大小-&gt;位置-&gt;绘制整个View树的绘图流程在ViewRoot.java类的performTraversals()函数展开，该函数所做 的工作可简单概况为是否需要重新计算视图大小(measure)、是否需要重新安置视图的位置(layout)、以及是否需要重绘(draw)]]></content>
      <tags>
        <tag>animation</tag>
      </tags>
  </entry>
</search>
